#if !defined(USE_MPI)
#error "You should specify USE_MPI=0 or USE_MPI=1 on the compile line"
#endif

// OpenMP will be compiled in if this flag is set to 1 AND the compiler beging
// used supports it (i.e. the _OPENMP symbol is defined)
//#define USE_OMP 1

#if USE_MPI
#include <mpi.h>

/*
   define one of these three symbols:

   SEDOV_SYNC_POS_VEL_NONE
   SEDOV_SYNC_POS_VEL_EARLY
   SEDOV_SYNC_POS_VEL_LATE
*/

#define SEDOV_SYNC_POS_VEL_EARLY 1
#endif

#include <stdlib.h>
#include <math.h>
#include <vector>

#include "RAJA/RAJA.hxx"

//
//   RAJA IndexSet type used in loop traversals.
//
typedef RAJA::IndexSet LULESH_ISET;

//**************************************************
// Allow flexibility for arithmetic representations
//**************************************************

#define MAX(a, b) (((a) > (b)) ? (a) : (b))

// Precision specification
typedef float real4;
typedef double real8;
typedef long double real10;  // 10 bytes on x86

typedef int Index_t;   // array subscript and loop index
typedef real8 Real_t;  // floating point representation
typedef int Int_t;     // integer representation

typedef Real_t* __restrict__ Real_p;
typedef Index_t* __restrict__ Index_p;
typedef Int_t* __restrict__ Int_p;

enum { VolumeError = -1, QStopError = -2 };

inline real4 SQRT(real4 arg) { return sqrtf(arg); }
inline real8 SQRT(real8 arg) { return sqrt(arg); }
inline real10 SQRT(real10 arg) { return sqrtl(arg); }

inline real4 CBRT(real4 arg) { return cbrtf(arg); }
inline real8 CBRT(real8 arg) { return cbrt(arg); }
inline real10 CBRT(real10 arg) { return cbrtl(arg); }

inline real4 FABS(real4 arg) { return fabsf(arg); }
inline real8 FABS(real8 arg) { return fabs(arg); }
inline real10 FABS(real10 arg) { return fabsl(arg); }

// Stuff needed for boundary conditions
// 2 BCs on each of 6 hexahedral faces (12 bits)
#define XI_M 0x00007
#define XI_M_SYMM 0x00001
#define XI_M_FREE 0x00002
#define XI_M_COMM 0x00004

#define XI_P 0x00038
#define XI_P_SYMM 0x00008
#define XI_P_FREE 0x00010
#define XI_P_COMM 0x00020

#define ETA_M 0x001c0
#define ETA_M_SYMM 0x00040
#define ETA_M_FREE 0x00080
#define ETA_M_COMM 0x00100

#define ETA_P 0x00e00
#define ETA_P_SYMM 0x00200
#define ETA_P_FREE 0x00400
#define ETA_P_COMM 0x00800

#define ZETA_M 0x07000
#define ZETA_M_SYMM 0x01000
#define ZETA_M_FREE 0x02000
#define ZETA_M_COMM 0x04000

#define ZETA_P 0x38000
#define ZETA_P_SYMM 0x08000
#define ZETA_P_FREE 0x10000
#define ZETA_P_COMM 0x20000

// MPI Message Tags
#define MSG_COMM_SBN 1024
#define MSG_SYNC_POS_VEL 2048
#define MSG_MONOQ 3072

#define MAX_FIELDS_PER_MPI_COMM 6

// Assume 128 byte coherence
// Assume Real_t is an "integral power of 2" bytes wide
#define CACHE_COHERENCE_PAD_REAL (128 / sizeof(Real_t))

#define CACHE_ALIGN_REAL(n) \
  (((n) + (CACHE_COHERENCE_PAD_REAL - 1)) & ~(CACHE_COHERENCE_PAD_REAL - 1))

//////////////////////////////////////////////////////
// Helper functions
//////////////////////////////////////////////////////

/* might want to add access methods so that memory can be */
/* better managed, as in luleshFT */

template <typename T>
inline T* Allocate(size_t size) {
  return static_cast<T*>(malloc(sizeof(T) * size));
}

template <typename T>
inline void Release(T** ptr) {
  if (*ptr != NULL) {
    free(*ptr);
    *ptr = NULL;
  }
}

template <typename T>
inline void Release(T* __restrict__* ptr) {
  if (*ptr != NULL) {
    free(*ptr);
    *ptr = NULL;
  }
}

//////////////////////////////////////////////////////
// Primary data structure
//////////////////////////////////////////////////////

/*
 * The implementation of the data abstraction used for lulesh
 * resides entirely in the Domain class below.  You can change
 * grouping and interleaving of fields here to maximize data layout
 * efficiency for your underlying architecture or compiler.
 *
 * For example, fields can be implemented as STL objects or
 * raw array pointers.  As another example, individual fields
 * m_x, m_y, m_z could be budled into
 *
 *    struct { Real_t x, y, z ; } *m_coord ;
 *
 * allowing accessor functions such as
 *
 *  "Real_t &x(Index_t idx) { return m_coord[idx].x ; }"
 *  "Real_t &y(Index_t idx) { return m_coord[idx].y ; }"
 *  "Real_t &z(Index_t idx) { return m_coord[idx].z ; }"
 */

class Domain {
 public:
  // Constructor
  Domain(Int_t numRanks,
         Index_t colLoc,
         Index_t rowLoc,
         Index_t planeLoc,
         Index_t nx,
         Int_t tp,
         Int_t nr,
         Int_t balance,
         Int_t cost);

  // Destructor
  ~Domain();

  //
  // ALLOCATION
  //

  void AllocateNodePersistent(Index_t numNode)  // Node-centered
  {
    x = Allocate<Real_t>(numNode);  // coordinates
    y = Allocate<Real_t>(numNode);
    z = Allocate<Real_t>(numNode);

    xd = Allocate<Real_t>(numNode);  // velocities
    yd = Allocate<Real_t>(numNode);
    zd = Allocate<Real_t>(numNode);

    xdd = Allocate<Real_t>(numNode);  // accelerations
    ydd = Allocate<Real_t>(numNode);
    zdd = Allocate<Real_t>(numNode);

    fx = Allocate<Real_t>(numNode);  // forces
    fy = Allocate<Real_t>(numNode);
    fz = Allocate<Real_t>(numNode);

    nodalMass = Allocate<Real_t>(numNode);  // mass
  }

  void AllocateElemPersistent(Index_t numElem)  // Elem-centered
  {
    nodelist = Allocate<Index_t>(8 * numElem);

    // elem connectivities through face
    lxim = Allocate<Index_t>(numElem);
    lxip = Allocate<Index_t>(numElem);
    letam = Allocate<Index_t>(numElem);
    letap = Allocate<Index_t>(numElem);
    lzetam = Allocate<Index_t>(numElem);
    lzetap = Allocate<Index_t>(numElem);

    elemBC = Allocate<Int_t>(numElem);

    e = Allocate<Real_t>(numElem);
    p = Allocate<Real_t>(numElem);

    q = Allocate<Real_t>(numElem);
    ql = Allocate<Real_t>(numElem);
    qq = Allocate<Real_t>(numElem);

    v = Allocate<Real_t>(numElem);

    volo = Allocate<Real_t>(numElem);
    delv = Allocate<Real_t>(numElem);
    vdov = Allocate<Real_t>(numElem);

    arealg = Allocate<Real_t>(numElem);

    ss = Allocate<Real_t>(numElem);

    elemMass = Allocate<Real_t>(numElem);

    vnew = Allocate<Real_t>(numElem);
  }

  void AllocateGradients(Index_t numElem, Index_t allElem) {
    // Position gradients
    delx_xi = Allocate<Real_t>(numElem);
    delx_eta = Allocate<Real_t>(numElem);
    delx_zeta = Allocate<Real_t>(numElem);

    // Velocity gradients
    delv_xi = Allocate<Real_t>(allElem);
    delv_eta = Allocate<Real_t>(allElem);
    delv_zeta = Allocate<Real_t>(allElem);
  }

  void DeallocateGradients() {
    Release(&delv_zeta);
    Release(&delv_eta);
    Release(&delv_xi);

    Release(&delx_zeta);
    Release(&delx_eta);
    Release(&delx_xi);
  }

  void AllocateStrains(Index_t numElem) {
    dxx = Allocate<Real_t>(numElem);
    dyy = Allocate<Real_t>(numElem);
    dzz = Allocate<Real_t>(numElem);
  }

  void DeallocateStrains() {
    Release(&dzz);
    Release(&dyy);
    Release(&dxx);
  }

  Index_t nodeElemCount(Index_t idx) {
    return m_nodeElemStart[idx + 1] - m_nodeElemStart[idx];
  }

  Index_p nodeElemCornerList(Index_t idx) {
    return &m_nodeElemCornerList[m_nodeElemStart[idx]];
  }

  // Region Centered

  Index_t& regElemSize(Index_t idx) { return m_regElemSize[idx]; }
  Index_t& regNumList(Index_t idx) { return m_regNumList[idx]; }
  Index_p regNumList() { return &m_regNumList[0]; }
  Index_p regElemlist(Int_t r) { return m_regElemlist[r]; }
  Index_t& regElemlist(Int_t r, Index_t idx) { return m_regElemlist[r][idx]; }

  // Parameters

  // Cutoffs
  Real_t u_cut() const { return m_u_cut; }
  Real_t e_cut() const { return m_e_cut; }
  Real_t p_cut() const { return m_p_cut; }
  Real_t q_cut() const { return m_q_cut; }
  Real_t v_cut() const { return m_v_cut; }

  // Other constants (usually are settable via input file in real codes)
  Real_t hgcoef() const { return m_hgcoef; }
  Real_t qstop() const { return m_qstop; }
  Real_t monoq_max_slope() const { return m_monoq_max_slope; }
  Real_t monoq_limiter_mult() const { return m_monoq_limiter_mult; }
  Real_t ss4o3() const { return m_ss4o3; }
  Real_t qlc_monoq() const { return m_qlc_monoq; }
  Real_t qqc_monoq() const { return m_qqc_monoq; }
  Real_t qqc() const { return m_qqc; }

  Real_t eosvmax() const { return m_eosvmax; }
  Real_t eosvmin() const { return m_eosvmin; }
  Real_t pmin() const { return m_pmin; }
  Real_t emin() const { return m_emin; }
  Real_t dvovmax() const { return m_dvovmax; }
  Real_t refdens() const { return m_refdens; }

  // Timestep controls, etc...
  Real_t& time() { return m_time; }
  Real_t& deltatime() { return m_deltatime; }
  Real_t& deltatimemultlb() { return m_deltatimemultlb; }
  Real_t& deltatimemultub() { return m_deltatimemultub; }
  Real_t& stoptime() { return m_stoptime; }
  Real_t& dtcourant() { return m_dtcourant; }
  Real_t& dthydro() { return m_dthydro; }
  Real_t& dtmax() { return m_dtmax; }
  Real_t& dtfixed() { return m_dtfixed; }

  Int_t& cycle() { return m_cycle; }
  Index_t& numRanks() { return m_numRanks; }

  Index_t& colLoc() { return m_colLoc; }
  Index_t& rowLoc() { return m_rowLoc; }
  Index_t& planeLoc() { return m_planeLoc; }
  Index_t& tp() { return m_tp; }

  Index_t& sizeX() { return m_sizeX; }
  Index_t& sizeY() { return m_sizeY; }
  Index_t& sizeZ() { return m_sizeZ; }
  Index_t& numReg() { return m_numReg; }
  Int_t& cost() { return m_cost; }
  Index_t& numElem() { return m_numElem; }
  Index_t& numNode() { return m_numNode; }

  Index_t& maxPlaneSize() { return m_maxPlaneSize; }
  Index_t& maxEdgeSize() { return m_maxEdgeSize; }

  //
  // Accessors for index sets
  //
  LULESH_ISET& getNodeISet() { return m_domNodeISet; }
  LULESH_ISET& getElemISet() { return m_domElemISet; }

  LULESH_ISET& getRegionISet(int r) { return m_domRegISet[r]; }

  LULESH_ISET& getXSymNodeISet() { return m_domXSymNodeISet; }
  LULESH_ISET& getYSymNodeISet() { return m_domYSymNodeISet; }
  LULESH_ISET& getZSymNodeISet() { return m_domZSymNodeISet; }

//
// MPI-Related additional data
//

#if USE_MPI
  // Communication Work space
  Real_p commDataSend;
  Real_p commDataRecv;

  // Maximum number of block neighbors
  MPI_Request recvRequest[26];  // 6 faces + 12 edges + 8 corners
  MPI_Request sendRequest[26];  // 6 faces + 12 edges + 8 corners
#endif

  //
  // IMPLEMENTATION
  //

  /* mesh-based index sets */
  LULESH_ISET m_domNodeISet;
  LULESH_ISET m_domElemISet;

  LULESH_ISET m_domXSymNodeISet;
  LULESH_ISET m_domYSymNodeISet;
  LULESH_ISET m_domZSymNodeISet;

  /* region-based index sets */
  std::vector<LULESH_ISET> m_domRegISet;

  /* Node-centered */
  Real_p x; /* coordinates */
  Real_p y;
  Real_p z;

  Real_p xd; /* velocities */
  Real_p yd;
  Real_p zd;

  Real_p xdd; /* accelerations */
  Real_p ydd;
  Real_p zdd;

  Real_p fx; /* forces */
  Real_p fy;
  Real_p fz;

  Real_p nodalMass; /* mass */

  // Element-centered

  Index_p nodelist; /* elemToNode connectivity */

  Index_p lxim; /* element connectivity across each face */
  Index_p lxip;
  Index_p letam;
  Index_p letap;
  Index_p lzetam;
  Index_p lzetap;

  Int_p elemBC; /* symmetry/free-surface flags for each elem face */

  Real_p dxx; /* principal strains -- temporary */
  Real_p dyy;
  Real_p dzz;

  Real_p delv_xi; /* velocity gradient -- temporary */
  Real_p delv_eta;
  Real_p delv_zeta;

  Real_p delx_xi; /* coordinate gradient -- temporary */
  Real_p delx_eta;
  Real_p delx_zeta;

  Real_p e; /* energy */

  Real_p p;  /* pressure */
  Real_p q;  /* q */
  Real_p ql; /* linear term for q */
  Real_p qq; /* quadratic term for q */

  Real_p v;    /* relative volume */
  Real_p volo; /* reference volume */
  Real_p vnew; /* new relative volume -- temporary */
  Real_p delv; /* m_vnew - m_v */
  Real_p vdov; /* volume derivative over volume */

  Real_p arealg; /* characteristic length of an element */

  Real_p ss; /* "sound speed" */

  Real_p elemMass; /* mass */

  // Region information
  Int_t m_numReg;
  Int_t m_cost;  // imbalance cost
  Index_p m_regElemSize;   // Size of region sets
  Index_p m_regNumList;    // Region number per domain element
  Index_p* m_regElemlist;  // region indexset

  // Permutation to pack element-centered material subsets
  // into a contiguous range per material
  Index_p m_perm;

  // Cutoffs (treat as constants)
  const Real_t m_e_cut;  // energy tolerance
  const Real_t m_p_cut;  // pressure tolerance
  const Real_t m_q_cut;  // q tolerance
  const Real_t m_v_cut;  // relative volume tolerance
  const Real_t m_u_cut;  // velocity tolerance

  // Other constants (usually setable, but hardcoded in this proxy app)

  const Real_t m_hgcoef;  // hourglass control
  const Real_t m_ss4o3;
  const Real_t m_qstop;  // excessive q indicator
  const Real_t m_monoq_max_slope;
  const Real_t m_monoq_limiter_mult;
  const Real_t m_qlc_monoq;  // linear term coef for q
  const Real_t m_qqc_monoq;  // quadratic term coef for q
  const Real_t m_qqc;
  const Real_t m_eosvmax;
  const Real_t m_eosvmin;
  const Real_t m_pmin;     // pressure floor
  const Real_t m_emin;     // energy floor
  const Real_t m_dvovmax;  // maximum allowable volume change
  const Real_t m_refdens;  // reference density

  // Variables to keep track of timestep, simulation time, and cycle
  Real_t m_dtcourant;  // courant constraint
  Real_t m_dthydro;    // volume change constraint
  Int_t m_cycle;       // iteration count for simulation
  Real_t m_dtfixed;    // fixed time increment
  Real_t m_time;       // current time
  Real_t m_deltatime;  // variable time increment
  Real_t m_deltatimemultlb;
  Real_t m_deltatimemultub;
  Real_t m_dtmax;     // maximum allowable time increment
  Real_t m_stoptime;  // end time for simulation

  Int_t m_numRanks;

  Index_t m_colLoc;
  Index_t m_rowLoc;
  Index_t m_planeLoc;
  Index_t m_tp;

  Index_t m_sizeX;
  Index_t m_sizeY;
  Index_t m_sizeZ;
  Index_t m_numElem;
  Index_t m_numNode;

  Index_t m_maxPlaneSize;
  Index_t m_maxEdgeSize;

  // OMP hack
  Index_p m_nodeElemStart;
  Index_p m_nodeElemCornerList;

  // Used in setup
  Index_t m_rowMin, m_rowMax;
  Index_t m_colMin, m_colMax;
  Index_t m_planeMin, m_planeMax;

 private:
  void BuildMeshTopology(Index_t edgeNodes, Index_t edgeElems);
  void BuildMeshCoordinates(Index_t nx, Index_t edgeNodes);
  void SetupThreadSupportStructures();
  void CreateMeshIndexSets();
  void CreateRegionIndexSets(Int_t nreg, Int_t balance);
  void CreateSymmetryIndexSets(Index_t edgeNodes);
  void SetupCommBuffers(Index_t edgeNodes);
  void SetupElementConnectivities(Index_t edgeElems);
  void SetupBoundaryConditions(Index_t edgeElems);
};

typedef Real_t& (Domain::*Domain_member)(Index_t);

struct cmdLineOpts {
  Int_t its;       // -i
  Int_t nx;        // -s
  Int_t numReg;    // -r
  Int_t numFiles;  // -f
  Int_t showProg;  // -p
  Int_t quiet;     // -q
  Int_t viz;       // -v
  Int_t cost;      // -c
  Int_t balance;   // -b
};

// Function Prototypes

// lulesh-par
Real_t CalcElemVolume(const Real_t x[8], const Real_t y[8], const Real_t z[8]);

// lulesh-util
void ParseCommandLineOptions(int argc,
                             char* argv[],
                             Int_t myRank,
                             struct cmdLineOpts* opts);
void VerifyAndWriteFinalOutput(Real_t elapsed_time,
                               Domain& locDom,
                               Int_t nx,
                               Int_t numRanks);

// lulesh-viz
void DumpToVisit(Domain& domain, int numFiles, int myRank, int numRanks);

// lulesh-comm
void CommRecv(Domain& domain,
              Int_t msgType,
              Index_t xferFields,
              Index_t dx,
              Index_t dy,
              Index_t dz,
              bool doRecv,
              bool planeOnly);
void CommSend(Domain& domain,
              Int_t msgType,
              Index_t xferFields,
              Domain_member* fieldData,
              Index_t dx,
              Index_t dy,
              Index_t dz,
              bool doSend,
              bool planeOnly);
void CommSBN(Domain& domain, Int_t xferFields, Domain_member* fieldData);
void CommSyncPosVel(Domain& domain);
void CommMonoQ(Domain& domain);

// lulesh-init
void InitMeshDecomp(Int_t numRanks,
                    Int_t myRank,
                    Int_t* col,
                    Int_t* row,
                    Int_t* plane,
                    Int_t* side);
