//AUTOGENERATED BY gen_forallN_generic.py

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
// Copyright (c) 2016, Lawrence Livermore National Security, LLC.
// 
// Produced at the Lawrence Livermore National Laboratory
// 
// LLNL-CODE-689114
// 
// All rights reserved.
// 
// This file is part of RAJA. 
// 
// For additional details, please also read raja/README-license.txt.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are met:
// 
// * Redistributions of source code must retain the above copyright notice, 
//   this list of conditions and the disclaimer below.
// 
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the disclaimer (as noted below) in the
//   documentation and/or other materials provided with the distribution.
// 
// * Neither the name of the LLNS/LLNL nor the names of its contributors may
//   be used to endorse or promote products derived from this software without
//   specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL SECURITY,
// LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
// DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
// IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
// POSSIBILITY OF SUCH DAMAGE.
// 
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

  
#ifndef RAJA_forallN_generic_HXX__
#define RAJA_forallN_generic_HXX__

#include "RAJA/forallN_generic_lf.hxx"

namespace RAJA {


/*!
 * \brief Provides abstraction of a 1-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename TI, typename BODY>
RAJA_INLINE
void forallN(TI const &is_i, BODY const &body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  using ExecPolicies = typename POLICY::ExecPolicies;
  using PolicyI = typename std::tuple_element<0, typename ExecPolicies::tuple>::type;
  
  // Create index type conversion layer
  typedef ForallN_IndexTypeConverter<BODY, IdxI> IDX_CONV;

  // call policy layer with next policy
  forallN_policy<NextPolicy, IDX_CONV>(NextPolicyTag(), IDX_CONV(body),
    ForallN_PolicyPair<PolicyI, TI>(is_i));
}

/*!
 * \brief Provides abstraction of a 2-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename TI, typename TJ, typename BODY>
RAJA_INLINE
void forallN(TI const &is_i, TJ const &is_j, BODY const &body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  using ExecPolicies = typename POLICY::ExecPolicies;
  using PolicyI = typename std::tuple_element<0, typename ExecPolicies::tuple>::type;
  using PolicyJ = typename std::tuple_element<1, typename ExecPolicies::tuple>::type;
  
  // Create index type conversion layer
  typedef ForallN_IndexTypeConverter<BODY, IdxI, IdxJ> IDX_CONV;

  // call policy layer with next policy
  forallN_policy<NextPolicy, IDX_CONV>(NextPolicyTag(), IDX_CONV(body),
    ForallN_PolicyPair<PolicyI, TI>(is_i),
    ForallN_PolicyPair<PolicyJ, TJ>(is_j));
}

/*!
 * \brief Provides abstraction of a 3-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename TI, typename TJ, typename TK, typename BODY>
RAJA_INLINE
void forallN(TI const &is_i, TJ const &is_j, TK const &is_k, BODY const &body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  using ExecPolicies = typename POLICY::ExecPolicies;
  using PolicyI = typename std::tuple_element<0, typename ExecPolicies::tuple>::type;
  using PolicyJ = typename std::tuple_element<1, typename ExecPolicies::tuple>::type;
  using PolicyK = typename std::tuple_element<2, typename ExecPolicies::tuple>::type;
  
  // Create index type conversion layer
  typedef ForallN_IndexTypeConverter<BODY, IdxI, IdxJ, IdxK> IDX_CONV;

  // call policy layer with next policy
  forallN_policy<NextPolicy, IDX_CONV>(NextPolicyTag(), IDX_CONV(body),
    ForallN_PolicyPair<PolicyI, TI>(is_i),
    ForallN_PolicyPair<PolicyJ, TJ>(is_j),
    ForallN_PolicyPair<PolicyK, TK>(is_k));
}

/*!
 * \brief Provides abstraction of a 4-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxL=Index_type, typename TI, typename TJ, typename TK, typename TL, typename BODY>
RAJA_INLINE
void forallN(TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, BODY const &body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  using ExecPolicies = typename POLICY::ExecPolicies;
  using PolicyI = typename std::tuple_element<0, typename ExecPolicies::tuple>::type;
  using PolicyJ = typename std::tuple_element<1, typename ExecPolicies::tuple>::type;
  using PolicyK = typename std::tuple_element<2, typename ExecPolicies::tuple>::type;
  using PolicyL = typename std::tuple_element<3, typename ExecPolicies::tuple>::type;
  
  // Create index type conversion layer
  typedef ForallN_IndexTypeConverter<BODY, IdxI, IdxJ, IdxK, IdxL> IDX_CONV;

  // call policy layer with next policy
  forallN_policy<NextPolicy, IDX_CONV>(NextPolicyTag(), IDX_CONV(body),
    ForallN_PolicyPair<PolicyI, TI>(is_i),
    ForallN_PolicyPair<PolicyJ, TJ>(is_j),
    ForallN_PolicyPair<PolicyK, TK>(is_k),
    ForallN_PolicyPair<PolicyL, TL>(is_l));
}

/*!
 * \brief Provides abstraction of a 5-nested loop
 *
 * Provides index typing, and initial nested policy unwrapping
 */
template<typename POLICY, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxL=Index_type, typename IdxM=Index_type, typename TI, typename TJ, typename TK, typename TL, typename TM, typename BODY>
RAJA_INLINE
void forallN(TI const &is_i, TJ const &is_j, TK const &is_k, TL const &is_l, TM const &is_m, BODY const &body){
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // extract each loop's execution policy
  using ExecPolicies = typename POLICY::ExecPolicies;
  using PolicyI = typename std::tuple_element<0, typename ExecPolicies::tuple>::type;
  using PolicyJ = typename std::tuple_element<1, typename ExecPolicies::tuple>::type;
  using PolicyK = typename std::tuple_element<2, typename ExecPolicies::tuple>::type;
  using PolicyL = typename std::tuple_element<3, typename ExecPolicies::tuple>::type;
  using PolicyM = typename std::tuple_element<4, typename ExecPolicies::tuple>::type;
  
  // Create index type conversion layer
  typedef ForallN_IndexTypeConverter<BODY, IdxI, IdxJ, IdxK, IdxL, IdxM> IDX_CONV;

  // call policy layer with next policy
  forallN_policy<NextPolicy, IDX_CONV>(NextPolicyTag(), IDX_CONV(body),
    ForallN_PolicyPair<PolicyI, TI>(is_i),
    ForallN_PolicyPair<PolicyJ, TJ>(is_j),
    ForallN_PolicyPair<PolicyK, TK>(is_k),
    ForallN_PolicyPair<PolicyL, TL>(is_l),
    ForallN_PolicyPair<PolicyM, TM>(is_m));
}



} // namespace RAJA
  
#endif

