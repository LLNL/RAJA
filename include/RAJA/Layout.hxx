//AUTOGENERATED BY genLayout.py
  
#ifndef RAJA_LAYOUT_HXX__
#define RAJA_LAYOUT_HXX__

#include <RAJA/IndexValue.hxx>

namespace RAJA {


struct PERM_I {};
struct PERM_IJ {};
struct PERM_JI {};
struct PERM_IJK {};
struct PERM_IKJ {};
struct PERM_JIK {};
struct PERM_JKI {};
struct PERM_KIJ {};
struct PERM_KJI {};
struct PERM_IJKL {};
struct PERM_IJLK {};
struct PERM_IKJL {};
struct PERM_IKLJ {};
struct PERM_ILJK {};
struct PERM_ILKJ {};
struct PERM_JIKL {};
struct PERM_JILK {};
struct PERM_JKIL {};
struct PERM_JKLI {};
struct PERM_JLIK {};
struct PERM_JLKI {};
struct PERM_KIJL {};
struct PERM_KILJ {};
struct PERM_KJIL {};
struct PERM_KJLI {};
struct PERM_KLIJ {};
struct PERM_KLJI {};
struct PERM_LIJK {};
struct PERM_LIKJ {};
struct PERM_LJIK {};
struct PERM_LJKI {};
struct PERM_LKIJ {};
struct PERM_LKJI {};
struct PERM_IJKLM {};
struct PERM_IJKML {};
struct PERM_IJLKM {};
struct PERM_IJLMK {};
struct PERM_IJMKL {};
struct PERM_IJMLK {};
struct PERM_IKJLM {};
struct PERM_IKJML {};
struct PERM_IKLJM {};
struct PERM_IKLMJ {};
struct PERM_IKMJL {};
struct PERM_IKMLJ {};
struct PERM_ILJKM {};
struct PERM_ILJMK {};
struct PERM_ILKJM {};
struct PERM_ILKMJ {};
struct PERM_ILMJK {};
struct PERM_ILMKJ {};
struct PERM_IMJKL {};
struct PERM_IMJLK {};
struct PERM_IMKJL {};
struct PERM_IMKLJ {};
struct PERM_IMLJK {};
struct PERM_IMLKJ {};
struct PERM_JIKLM {};
struct PERM_JIKML {};
struct PERM_JILKM {};
struct PERM_JILMK {};
struct PERM_JIMKL {};
struct PERM_JIMLK {};
struct PERM_JKILM {};
struct PERM_JKIML {};
struct PERM_JKLIM {};
struct PERM_JKLMI {};
struct PERM_JKMIL {};
struct PERM_JKMLI {};
struct PERM_JLIKM {};
struct PERM_JLIMK {};
struct PERM_JLKIM {};
struct PERM_JLKMI {};
struct PERM_JLMIK {};
struct PERM_JLMKI {};
struct PERM_JMIKL {};
struct PERM_JMILK {};
struct PERM_JMKIL {};
struct PERM_JMKLI {};
struct PERM_JMLIK {};
struct PERM_JMLKI {};
struct PERM_KIJLM {};
struct PERM_KIJML {};
struct PERM_KILJM {};
struct PERM_KILMJ {};
struct PERM_KIMJL {};
struct PERM_KIMLJ {};
struct PERM_KJILM {};
struct PERM_KJIML {};
struct PERM_KJLIM {};
struct PERM_KJLMI {};
struct PERM_KJMIL {};
struct PERM_KJMLI {};
struct PERM_KLIJM {};
struct PERM_KLIMJ {};
struct PERM_KLJIM {};
struct PERM_KLJMI {};
struct PERM_KLMIJ {};
struct PERM_KLMJI {};
struct PERM_KMIJL {};
struct PERM_KMILJ {};
struct PERM_KMJIL {};
struct PERM_KMJLI {};
struct PERM_KMLIJ {};
struct PERM_KMLJI {};
struct PERM_LIJKM {};
struct PERM_LIJMK {};
struct PERM_LIKJM {};
struct PERM_LIKMJ {};
struct PERM_LIMJK {};
struct PERM_LIMKJ {};
struct PERM_LJIKM {};
struct PERM_LJIMK {};
struct PERM_LJKIM {};
struct PERM_LJKMI {};
struct PERM_LJMIK {};
struct PERM_LJMKI {};
struct PERM_LKIJM {};
struct PERM_LKIMJ {};
struct PERM_LKJIM {};
struct PERM_LKJMI {};
struct PERM_LKMIJ {};
struct PERM_LKMJI {};
struct PERM_LMIJK {};
struct PERM_LMIKJ {};
struct PERM_LMJIK {};
struct PERM_LMJKI {};
struct PERM_LMKIJ {};
struct PERM_LMKJI {};
struct PERM_MIJKL {};
struct PERM_MIJLK {};
struct PERM_MIKJL {};
struct PERM_MIKLJ {};
struct PERM_MILJK {};
struct PERM_MILKJ {};
struct PERM_MJIKL {};
struct PERM_MJILK {};
struct PERM_MJKIL {};
struct PERM_MJKLI {};
struct PERM_MJLIK {};
struct PERM_MJLKI {};
struct PERM_MKIJL {};
struct PERM_MKILJ {};
struct PERM_MKJIL {};
struct PERM_MKJLI {};
struct PERM_MKLIJ {};
struct PERM_MKLJI {};
struct PERM_MLIJK {};
struct PERM_MLIKJ {};
struct PERM_MLJIK {};
struct PERM_MLJKI {};
struct PERM_MLKIJ {};
struct PERM_MLKJI {};

template<typename Perm, typename IdxI=Index_type, typename IdxLin=Index_type>
struct Layout1d {};

template<typename Perm, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxLin=Index_type>
struct Layout2d {};

template<typename Perm, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxLin=Index_type>
struct Layout3d {};

template<typename Perm, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxL=Index_type, typename IdxLin=Index_type>
struct Layout4d {};

template<typename Perm, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxL=Index_type, typename IdxM=Index_type, typename IdxLin=Index_type>
struct Layout5d {};


/******************************************************************
 *  Implementation for Layout1D
 ******************************************************************/

template<typename IdxI, typename IdxLin>
struct Layout1d<PERM_I, IdxI, IdxLin> {
  typedef PERM_I Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;

  Index_type const size_i;

  Index_type const stride_i;

  inline Layout1d(Index_type ni):
    size_i(ni), stride_i(1)
  {}

  inline IdxLin operator()(IdxI i) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i) const {
    Index_type linear = convertIndex<Index_type>(lin);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout2D
 ******************************************************************/

template<typename IdxI, typename IdxJ, typename IdxLin>
struct Layout2d<PERM_IJ, IdxI, IdxJ, IdxLin> {
  typedef PERM_IJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;

  Index_type const size_i;
  Index_type const size_j;

  Index_type const stride_i;
  Index_type const stride_j;

  inline Layout2d(Index_type ni, Index_type nj):
    size_i(ni), size_j(nj), stride_i(nj), stride_j(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxLin>
struct Layout2d<PERM_JI, IdxI, IdxJ, IdxLin> {
  typedef PERM_JI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;

  Index_type const size_i;
  Index_type const size_j;

  Index_type const stride_i;
  Index_type const stride_j;

  inline Layout2d(Index_type ni, Index_type nj):
    size_i(ni), size_j(nj), stride_i(1), stride_j(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout3D
 ******************************************************************/

template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_IJK, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_IJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nj*nk), stride_j(nk), stride_k(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_IKJ, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_IKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nk*nj), stride_j(1), stride_k(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_JIK, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_JIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nk), stride_j(ni*nk), stride_k(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_JKI, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_JKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(nk*ni), stride_k(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_KIJ, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_KIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nj), stride_j(1), stride_k(ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_KJI, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_KJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(ni), stride_k(nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout4D
 ******************************************************************/

template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IJKL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IJKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_l);
    Index_type _j = linear / (size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IJLK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IJLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_k);
    Index_type _j = linear / (size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IKJL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IKJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_l);
    Index_type _k = linear / (size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IKLJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IKLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_j);
    Index_type _k = linear / (size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_ILJK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_ILJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_k);
    Index_type _l = linear / (size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_ILKJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_ILKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_j);
    Index_type _l = linear / (size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JIKL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JIKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl), stride_j(ni*nk*nl), stride_k(nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_l);
    Index_type _i = linear / (size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JILK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JILK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk), stride_j(ni*nl*nk), stride_k(1), stride_l(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_k);
    Index_type _i = linear / (size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JKIL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JKIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(nk*ni*nl), stride_k(ni*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_l);
    Index_type _k = linear / (size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JKLI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JKLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*nl*ni), stride_k(nl*ni), stride_l(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_i);
    Index_type _k = linear / (size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JLIK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JLIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(nl*ni*nk), stride_k(1), stride_l(ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_k);
    Index_type _l = linear / (size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JLKI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JLKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*nk*ni), stride_k(ni), stride_l(nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_i);
    Index_type _l = linear / (size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KIJL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KIJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl), stride_j(nl), stride_k(ni*nj*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_l);
    Index_type _i = linear / (size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KILJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KILJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj), stride_j(1), stride_k(ni*nl*nj), stride_l(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_j);
    Index_type _i = linear / (size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KJIL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KJIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(ni*nl), stride_k(nj*ni*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_l);
    Index_type _j = linear / (size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KJLI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KJLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*ni), stride_k(nj*nl*ni), stride_l(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_i);
    Index_type _j = linear / (size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KLIJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KLIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(nl*ni*nj), stride_l(ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_j);
    Index_type _l = linear / (size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KLJI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KLJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nl*nj*ni), stride_l(nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_i);
    Index_type _l = linear / (size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LIJK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LIJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_k);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LIKJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LIKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_j);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LJIK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LJIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nj*ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_k);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LJKI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LJKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nj*nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_i);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LKIJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LKIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nk*ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_j);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LKJI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LKJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nk*nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_i);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout5D
 ******************************************************************/

template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IJKLM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IJKLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nl*nm), stride_j(nk*nl*nm), stride_k(nl*nm), stride_l(nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_l*size_m);
    Index_type _j = linear / (size_k*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_m);
    Index_type _k = linear / (size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IJKML, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IJKML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nm*nl), stride_j(nk*nm*nl), stride_k(nm*nl), stride_l(1), stride_m(nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_m*size_l);
    Index_type _j = linear / (size_k*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_l);
    Index_type _k = linear / (size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IJLKM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IJLKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nk*nm), stride_j(nl*nk*nm), stride_k(nm), stride_l(nk*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_l*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_k*size_m);
    Index_type _j = linear / (size_l*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_m);
    Index_type _l = linear / (size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IJLMK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IJLMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nm*nk), stride_j(nl*nm*nk), stride_k(1), stride_l(nm*nk), stride_m(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_l*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_m*size_k);
    Index_type _j = linear / (size_l*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_k);
    Index_type _l = linear / (size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IJMKL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IJMKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nk*nl), stride_j(nm*nk*nl), stride_k(nl), stride_l(1), stride_m(nk*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_m*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_k*size_l);
    Index_type _j = linear / (size_m*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_l);
    Index_type _m = linear / (size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IJMLK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IJMLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nl*nk), stride_j(nm*nl*nk), stride_k(1), stride_l(nk), stride_m(nl*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_m*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_l*size_k);
    Index_type _j = linear / (size_m*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_k);
    Index_type _m = linear / (size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IKJLM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IKJLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nl*nm), stride_j(nl*nm), stride_k(nj*nl*nm), stride_l(nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_l*size_m);
    Index_type _k = linear / (size_j*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_m);
    Index_type _j = linear / (size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IKJML, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IKJML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nm*nl), stride_j(nm*nl), stride_k(nj*nm*nl), stride_l(1), stride_m(nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_m*size_l);
    Index_type _k = linear / (size_j*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_l);
    Index_type _j = linear / (size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IKLJM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IKLJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nj*nm), stride_j(nm), stride_k(nl*nj*nm), stride_l(nj*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_l*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_j*size_m);
    Index_type _k = linear / (size_l*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_m);
    Index_type _l = linear / (size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IKLMJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IKLMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nm*nj), stride_j(1), stride_k(nl*nm*nj), stride_l(nm*nj), stride_m(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_l*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_m*size_j);
    Index_type _k = linear / (size_l*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_j);
    Index_type _l = linear / (size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IKMJL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IKMJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nj*nl), stride_j(nl), stride_k(nm*nj*nl), stride_l(1), stride_m(nj*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_m*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_j*size_l);
    Index_type _k = linear / (size_m*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_l);
    Index_type _m = linear / (size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IKMLJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IKMLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nl*nj), stride_j(1), stride_k(nm*nl*nj), stride_l(nj), stride_m(nl*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_m*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_l*size_j);
    Index_type _k = linear / (size_m*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_j);
    Index_type _m = linear / (size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_ILJKM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_ILJKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nk*nm), stride_j(nk*nm), stride_k(nm), stride_l(nj*nk*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_j*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_k*size_m);
    Index_type _l = linear / (size_j*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_m);
    Index_type _j = linear / (size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_ILJMK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_ILJMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nm*nk), stride_j(nm*nk), stride_k(1), stride_l(nj*nm*nk), stride_m(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_j*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_m*size_k);
    Index_type _l = linear / (size_j*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_k);
    Index_type _j = linear / (size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_ILKJM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_ILKJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nj*nm), stride_j(nm), stride_k(nj*nm), stride_l(nk*nj*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_k*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_j*size_m);
    Index_type _l = linear / (size_k*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_m);
    Index_type _k = linear / (size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_ILKMJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_ILKMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nm*nj), stride_j(1), stride_k(nm*nj), stride_l(nk*nm*nj), stride_m(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_k*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_m*size_j);
    Index_type _l = linear / (size_k*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_j);
    Index_type _k = linear / (size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_ILMJK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_ILMJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nj*nk), stride_j(nk), stride_k(1), stride_l(nm*nj*nk), stride_m(nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_m*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_j*size_k);
    Index_type _l = linear / (size_m*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_k);
    Index_type _m = linear / (size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_ILMKJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_ILMKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nk*nj), stride_j(1), stride_k(nj), stride_l(nm*nk*nj), stride_m(nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_m*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_k*size_j);
    Index_type _l = linear / (size_m*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_j);
    Index_type _m = linear / (size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IMJKL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IMJKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1), stride_m(nj*nk*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_j*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_k*size_l);
    Index_type _m = linear / (size_j*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_l);
    Index_type _j = linear / (size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IMJLK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IMJLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk), stride_m(nj*nl*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_j*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_l*size_k);
    Index_type _m = linear / (size_j*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_k);
    Index_type _j = linear / (size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IMKJL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IMKJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1), stride_m(nk*nj*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_k*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_j*size_l);
    Index_type _m = linear / (size_k*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_l);
    Index_type _k = linear / (size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IMKLJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IMKLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj), stride_m(nk*nl*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_k*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_l*size_j);
    Index_type _m = linear / (size_k*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_j);
    Index_type _k = linear / (size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IMLJK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IMLJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk), stride_m(nl*nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_l*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_j*size_k);
    Index_type _m = linear / (size_l*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_k);
    Index_type _l = linear / (size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_IMLKJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_IMLKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj), stride_m(nl*nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_l*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_k*size_j);
    Index_type _m = linear / (size_l*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_j);
    Index_type _l = linear / (size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JIKLM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JIKLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nm), stride_j(ni*nk*nl*nm), stride_k(nl*nm), stride_l(nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_l*size_m);
    Index_type _i = linear / (size_k*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_m);
    Index_type _k = linear / (size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JIKML, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JIKML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nl), stride_j(ni*nk*nm*nl), stride_k(nm*nl), stride_l(1), stride_m(nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_m*size_l);
    Index_type _i = linear / (size_k*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_l);
    Index_type _k = linear / (size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JILKM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JILKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nm), stride_j(ni*nl*nk*nm), stride_k(nm), stride_l(nk*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_l*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_k*size_m);
    Index_type _i = linear / (size_l*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_m);
    Index_type _l = linear / (size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JILMK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JILMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nk), stride_j(ni*nl*nm*nk), stride_k(1), stride_l(nm*nk), stride_m(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_l*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_m*size_k);
    Index_type _i = linear / (size_l*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_k);
    Index_type _l = linear / (size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JIMKL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JIMKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nl), stride_j(ni*nm*nk*nl), stride_k(nl), stride_l(1), stride_m(nk*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_m*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_k*size_l);
    Index_type _i = linear / (size_m*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_l);
    Index_type _m = linear / (size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JIMLK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JIMLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nk), stride_j(ni*nm*nl*nk), stride_k(1), stride_l(nk), stride_m(nl*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_m*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_l*size_k);
    Index_type _i = linear / (size_m*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_k);
    Index_type _m = linear / (size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JKILM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JKILM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm), stride_j(nk*ni*nl*nm), stride_k(ni*nl*nm), stride_l(nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_l*size_m);
    Index_type _k = linear / (size_i*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_m);
    Index_type _i = linear / (size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JKIML, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JKIML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl), stride_j(nk*ni*nm*nl), stride_k(ni*nm*nl), stride_l(1), stride_m(nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_m*size_l);
    Index_type _k = linear / (size_i*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_l);
    Index_type _i = linear / (size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JKLIM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JKLIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nk*nl*ni*nm), stride_k(nl*ni*nm), stride_l(ni*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_l*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_i*size_m);
    Index_type _k = linear / (size_l*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_m);
    Index_type _l = linear / (size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JKLMI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JKLMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nl*nm*ni), stride_k(nl*nm*ni), stride_l(nm*ni), stride_m(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_l*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_m*size_i);
    Index_type _k = linear / (size_l*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_i);
    Index_type _l = linear / (size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JKMIL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JKMIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nk*nm*ni*nl), stride_k(nm*ni*nl), stride_l(1), stride_m(ni*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_m*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_i*size_l);
    Index_type _k = linear / (size_m*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_l);
    Index_type _m = linear / (size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JKMLI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JKMLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nm*nl*ni), stride_k(nm*nl*ni), stride_l(ni), stride_m(nl*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_m*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_l*size_i);
    Index_type _k = linear / (size_m*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_i);
    Index_type _m = linear / (size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JLIKM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JLIKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm), stride_j(nl*ni*nk*nm), stride_k(nm), stride_l(ni*nk*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_i*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_k*size_m);
    Index_type _l = linear / (size_i*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_m);
    Index_type _i = linear / (size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JLIMK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JLIMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk), stride_j(nl*ni*nm*nk), stride_k(1), stride_l(ni*nm*nk), stride_m(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_i*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_m*size_k);
    Index_type _l = linear / (size_i*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_k);
    Index_type _i = linear / (size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JLKIM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JLKIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nl*nk*ni*nm), stride_k(ni*nm), stride_l(nk*ni*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_k*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_i*size_m);
    Index_type _l = linear / (size_k*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_m);
    Index_type _k = linear / (size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JLKMI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JLKMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nk*nm*ni), stride_k(nm*ni), stride_l(nk*nm*ni), stride_m(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_k*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_m*size_i);
    Index_type _l = linear / (size_k*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_i);
    Index_type _k = linear / (size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JLMIK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JLMIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nl*nm*ni*nk), stride_k(1), stride_l(nm*ni*nk), stride_m(ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_m*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_i*size_k);
    Index_type _l = linear / (size_m*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_k);
    Index_type _m = linear / (size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JLMKI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JLMKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nm*nk*ni), stride_k(ni), stride_l(nm*nk*ni), stride_m(nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_m*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_k*size_i);
    Index_type _l = linear / (size_m*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_i);
    Index_type _m = linear / (size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JMIKL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JMIKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl), stride_j(nm*ni*nk*nl), stride_k(nl), stride_l(1), stride_m(ni*nk*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_i*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_k*size_l);
    Index_type _m = linear / (size_i*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_l);
    Index_type _i = linear / (size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JMILK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JMILK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk), stride_j(nm*ni*nl*nk), stride_k(1), stride_l(nk), stride_m(ni*nl*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_i*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_l*size_k);
    Index_type _m = linear / (size_i*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_k);
    Index_type _i = linear / (size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JMKIL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JMKIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nm*nk*ni*nl), stride_k(ni*nl), stride_l(1), stride_m(nk*ni*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_k*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_i*size_l);
    Index_type _m = linear / (size_k*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_l);
    Index_type _k = linear / (size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JMKLI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JMKLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nk*nl*ni), stride_k(nl*ni), stride_l(ni), stride_m(nk*nl*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_k*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_l*size_i);
    Index_type _m = linear / (size_k*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_i);
    Index_type _k = linear / (size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JMLIK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JMLIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nm*nl*ni*nk), stride_k(1), stride_l(ni*nk), stride_m(nl*ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_l*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_i*size_k);
    Index_type _m = linear / (size_l*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_k);
    Index_type _l = linear / (size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_JMLKI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_JMLKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nl*nk*ni), stride_k(ni), stride_l(nk*ni), stride_m(nl*nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_l*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_k*size_i);
    Index_type _m = linear / (size_l*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_i);
    Index_type _l = linear / (size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KIJLM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KIJLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nm), stride_j(nl*nm), stride_k(ni*nj*nl*nm), stride_l(nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_l*size_m);
    Index_type _i = linear / (size_j*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_m);
    Index_type _j = linear / (size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KIJML, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KIJML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nl), stride_j(nm*nl), stride_k(ni*nj*nm*nl), stride_l(1), stride_m(nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_m*size_l);
    Index_type _i = linear / (size_j*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_l);
    Index_type _j = linear / (size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KILJM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KILJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nm), stride_j(nm), stride_k(ni*nl*nj*nm), stride_l(nj*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_l*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_j*size_m);
    Index_type _i = linear / (size_l*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_m);
    Index_type _l = linear / (size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KILMJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KILMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nj), stride_j(1), stride_k(ni*nl*nm*nj), stride_l(nm*nj), stride_m(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_l*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_m*size_j);
    Index_type _i = linear / (size_l*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_j);
    Index_type _l = linear / (size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KIMJL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KIMJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nl), stride_j(nl), stride_k(ni*nm*nj*nl), stride_l(1), stride_m(nj*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_m*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_j*size_l);
    Index_type _i = linear / (size_m*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_l);
    Index_type _m = linear / (size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KIMLJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KIMLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nj), stride_j(1), stride_k(ni*nm*nl*nj), stride_l(nj), stride_m(nl*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_m*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_l*size_j);
    Index_type _i = linear / (size_m*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_j);
    Index_type _m = linear / (size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KJILM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KJILM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm), stride_j(ni*nl*nm), stride_k(nj*ni*nl*nm), stride_l(nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_l*size_m);
    Index_type _j = linear / (size_i*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_m);
    Index_type _i = linear / (size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KJIML, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KJIML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl), stride_j(ni*nm*nl), stride_k(nj*ni*nm*nl), stride_l(1), stride_m(nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_m*size_l);
    Index_type _j = linear / (size_i*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_l);
    Index_type _i = linear / (size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KJLIM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KJLIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nl*ni*nm), stride_k(nj*nl*ni*nm), stride_l(ni*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_l*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_i*size_m);
    Index_type _j = linear / (size_l*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_m);
    Index_type _l = linear / (size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KJLMI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KJLMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nm*ni), stride_k(nj*nl*nm*ni), stride_l(nm*ni), stride_m(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_l*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_m*size_i);
    Index_type _j = linear / (size_l*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_i);
    Index_type _l = linear / (size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KJMIL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KJMIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nm*ni*nl), stride_k(nj*nm*ni*nl), stride_l(1), stride_m(ni*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_m*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_i*size_l);
    Index_type _j = linear / (size_m*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_l);
    Index_type _m = linear / (size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KJMLI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KJMLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nl*ni), stride_k(nj*nm*nl*ni), stride_l(ni), stride_m(nl*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_m*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_l*size_i);
    Index_type _j = linear / (size_m*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_i);
    Index_type _m = linear / (size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KLIJM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KLIJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm), stride_j(nm), stride_k(nl*ni*nj*nm), stride_l(ni*nj*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_i*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_j*size_m);
    Index_type _l = linear / (size_i*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_m);
    Index_type _i = linear / (size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KLIMJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KLIMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj), stride_j(1), stride_k(nl*ni*nm*nj), stride_l(ni*nm*nj), stride_m(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_i*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_m*size_j);
    Index_type _l = linear / (size_i*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_j);
    Index_type _i = linear / (size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KLJIM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KLJIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(ni*nm), stride_k(nl*nj*ni*nm), stride_l(nj*ni*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_j*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_i*size_m);
    Index_type _l = linear / (size_j*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_m);
    Index_type _j = linear / (size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KLJMI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KLJMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*ni), stride_k(nl*nj*nm*ni), stride_l(nj*nm*ni), stride_m(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_j*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_m*size_i);
    Index_type _l = linear / (size_j*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_i);
    Index_type _j = linear / (size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KLMIJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KLMIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nl*nm*ni*nj), stride_l(nm*ni*nj), stride_m(ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_m*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_i*size_j);
    Index_type _l = linear / (size_m*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_j);
    Index_type _m = linear / (size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KLMJI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KLMJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nl*nm*nj*ni), stride_l(nm*nj*ni), stride_m(nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_m*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_j*size_i);
    Index_type _l = linear / (size_m*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_i);
    Index_type _m = linear / (size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KMIJL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KMIJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl), stride_j(nl), stride_k(nm*ni*nj*nl), stride_l(1), stride_m(ni*nj*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_i*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_j*size_l);
    Index_type _m = linear / (size_i*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_l);
    Index_type _i = linear / (size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KMILJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KMILJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj), stride_j(1), stride_k(nm*ni*nl*nj), stride_l(nj), stride_m(ni*nl*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_i*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_l*size_j);
    Index_type _m = linear / (size_i*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_j);
    Index_type _i = linear / (size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KMJIL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KMJIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(ni*nl), stride_k(nm*nj*ni*nl), stride_l(1), stride_m(nj*ni*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_j*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_i*size_l);
    Index_type _m = linear / (size_j*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_l);
    Index_type _j = linear / (size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KMJLI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KMJLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*ni), stride_k(nm*nj*nl*ni), stride_l(ni), stride_m(nj*nl*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_j*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_l*size_i);
    Index_type _m = linear / (size_j*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_i);
    Index_type _j = linear / (size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KMLIJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KMLIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nm*nl*ni*nj), stride_l(ni*nj), stride_m(nl*ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_l*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_i*size_j);
    Index_type _m = linear / (size_l*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_j);
    Index_type _l = linear / (size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_KMLJI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_KMLJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nm*nl*nj*ni), stride_l(nj*ni), stride_m(nl*nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_l*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_j*size_i);
    Index_type _m = linear / (size_l*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_i);
    Index_type _l = linear / (size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LIJKM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LIJKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nm), stride_j(nk*nm), stride_k(nm), stride_l(ni*nj*nk*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_j*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_k*size_m);
    Index_type _i = linear / (size_j*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_m);
    Index_type _j = linear / (size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LIJMK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LIJMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nk), stride_j(nm*nk), stride_k(1), stride_l(ni*nj*nm*nk), stride_m(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_j*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_m*size_k);
    Index_type _i = linear / (size_j*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_k);
    Index_type _j = linear / (size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LIKJM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LIKJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nm), stride_j(nm), stride_k(nj*nm), stride_l(ni*nk*nj*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_k*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_j*size_m);
    Index_type _i = linear / (size_k*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_m);
    Index_type _k = linear / (size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LIKMJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LIKMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nj), stride_j(1), stride_k(nm*nj), stride_l(ni*nk*nm*nj), stride_m(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_k*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_m*size_j);
    Index_type _i = linear / (size_k*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_j);
    Index_type _k = linear / (size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LIMJK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LIMJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nm*nj*nk), stride_m(nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_m*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_j*size_k);
    Index_type _i = linear / (size_m*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_k);
    Index_type _m = linear / (size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LIMKJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LIMKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nm*nk*nj), stride_m(nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_m*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_k*size_j);
    Index_type _i = linear / (size_m*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_j);
    Index_type _m = linear / (size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LJIKM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LJIKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm), stride_j(ni*nk*nm), stride_k(nm), stride_l(nj*ni*nk*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_i*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_k*size_m);
    Index_type _j = linear / (size_i*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_m);
    Index_type _i = linear / (size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LJIMK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LJIMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk), stride_j(ni*nm*nk), stride_k(1), stride_l(nj*ni*nm*nk), stride_m(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_i*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_m*size_k);
    Index_type _j = linear / (size_i*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_k);
    Index_type _i = linear / (size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LJKIM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LJKIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nk*ni*nm), stride_k(ni*nm), stride_l(nj*nk*ni*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_k*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_i*size_m);
    Index_type _j = linear / (size_k*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_m);
    Index_type _k = linear / (size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LJKMI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LJKMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nm*ni), stride_k(nm*ni), stride_l(nj*nk*nm*ni), stride_m(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_k*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_m*size_i);
    Index_type _j = linear / (size_k*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_i);
    Index_type _k = linear / (size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LJMIK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LJMIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nm*ni*nk), stride_k(1), stride_l(nj*nm*ni*nk), stride_m(ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_m*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_i*size_k);
    Index_type _j = linear / (size_m*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_k);
    Index_type _m = linear / (size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LJMKI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LJMKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nk*ni), stride_k(ni), stride_l(nj*nm*nk*ni), stride_m(nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_m*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_k*size_i);
    Index_type _j = linear / (size_m*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_i);
    Index_type _m = linear / (size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LKIJM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LKIJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm), stride_j(nm), stride_k(ni*nj*nm), stride_l(nk*ni*nj*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_i*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_j*size_m);
    Index_type _k = linear / (size_i*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_m);
    Index_type _i = linear / (size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LKIMJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LKIMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj), stride_j(1), stride_k(ni*nm*nj), stride_l(nk*ni*nm*nj), stride_m(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_i*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_m*size_j);
    Index_type _k = linear / (size_i*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_j);
    Index_type _i = linear / (size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LKJIM, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LKJIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(ni*nm), stride_k(nj*ni*nm), stride_l(nk*nj*ni*nm), stride_m(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_j*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_i*size_m);
    Index_type _k = linear / (size_j*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_m);
    Index_type _j = linear / (size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LKJMI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LKJMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*ni), stride_k(nj*nm*ni), stride_l(nk*nj*nm*ni), stride_m(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_j*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_m*size_i);
    Index_type _k = linear / (size_j*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_i);
    Index_type _j = linear / (size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LKMIJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LKMIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nm*ni*nj), stride_l(nk*nm*ni*nj), stride_m(ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_m*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_i*size_j);
    Index_type _k = linear / (size_m*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_j);
    Index_type _m = linear / (size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LKMJI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LKMJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nm*nj*ni), stride_l(nk*nm*nj*ni), stride_m(nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_m*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_j*size_i);
    Index_type _k = linear / (size_m*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_i);
    Index_type _m = linear / (size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LMIJK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LMIJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(nm*ni*nj*nk), stride_m(ni*nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_i*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_j*size_k);
    Index_type _m = linear / (size_i*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_k);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LMIKJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LMIKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(nm*ni*nk*nj), stride_m(ni*nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_i*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_k*size_j);
    Index_type _m = linear / (size_i*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_j);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LMJIK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LMJIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nm*nj*ni*nk), stride_m(nj*ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_j*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_i*size_k);
    Index_type _m = linear / (size_j*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_k);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LMJKI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LMJKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nm*nj*nk*ni), stride_m(nj*nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_j*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_k*size_i);
    Index_type _m = linear / (size_j*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_i);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LMKIJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LMKIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nm*nk*ni*nj), stride_m(nk*ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_k*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_i*size_j);
    Index_type _m = linear / (size_k*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_j);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_LMKJI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_LMKJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nm*nk*nj*ni), stride_m(nk*nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_k*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_j*size_i);
    Index_type _m = linear / (size_k*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_i);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MIJKL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MIJKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1), stride_m(ni*nj*nk*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_j*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_k*size_l);
    Index_type _i = linear / (size_j*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_l);
    Index_type _j = linear / (size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MIJLK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MIJLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk), stride_m(ni*nj*nl*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_j*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_l*size_k);
    Index_type _i = linear / (size_j*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_k);
    Index_type _j = linear / (size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MIKJL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MIKJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1), stride_m(ni*nk*nj*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_k*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_j*size_l);
    Index_type _i = linear / (size_k*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_l);
    Index_type _k = linear / (size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MIKLJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MIKLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj), stride_m(ni*nk*nl*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_k*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_l*size_j);
    Index_type _i = linear / (size_k*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_j);
    Index_type _k = linear / (size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MILJK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MILJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk), stride_m(ni*nl*nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_l*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_j*size_k);
    Index_type _i = linear / (size_l*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_k);
    Index_type _l = linear / (size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MILKJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MILKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj), stride_m(ni*nl*nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_l*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_k*size_j);
    Index_type _i = linear / (size_l*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_j);
    Index_type _l = linear / (size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MJIKL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MJIKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl), stride_j(ni*nk*nl), stride_k(nl), stride_l(1), stride_m(nj*ni*nk*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_i*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_k*size_l);
    Index_type _j = linear / (size_i*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_l);
    Index_type _i = linear / (size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MJILK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MJILK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk), stride_j(ni*nl*nk), stride_k(1), stride_l(nk), stride_m(nj*ni*nl*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_i*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_l*size_k);
    Index_type _j = linear / (size_i*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_k);
    Index_type _i = linear / (size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MJKIL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MJKIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nk*ni*nl), stride_k(ni*nl), stride_l(1), stride_m(nj*nk*ni*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_k*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_i*size_l);
    Index_type _j = linear / (size_k*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_l);
    Index_type _k = linear / (size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MJKLI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MJKLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nl*ni), stride_k(nl*ni), stride_l(ni), stride_m(nj*nk*nl*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_k*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_l*size_i);
    Index_type _j = linear / (size_k*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_i);
    Index_type _k = linear / (size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MJLIK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MJLIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nl*ni*nk), stride_k(1), stride_l(ni*nk), stride_m(nj*nl*ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_l*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_i*size_k);
    Index_type _j = linear / (size_l*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_k);
    Index_type _l = linear / (size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MJLKI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MJLKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nk*ni), stride_k(ni), stride_l(nk*ni), stride_m(nj*nl*nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_l*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_k*size_i);
    Index_type _j = linear / (size_l*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_i);
    Index_type _l = linear / (size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MKIJL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MKIJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl), stride_j(nl), stride_k(ni*nj*nl), stride_l(1), stride_m(nk*ni*nj*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_i*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_j*size_l);
    Index_type _k = linear / (size_i*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_l);
    Index_type _i = linear / (size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MKILJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MKILJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj), stride_j(1), stride_k(ni*nl*nj), stride_l(nj), stride_m(nk*ni*nl*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_i*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_l*size_j);
    Index_type _k = linear / (size_i*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_j);
    Index_type _i = linear / (size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MKJIL, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MKJIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(ni*nl), stride_k(nj*ni*nl), stride_l(1), stride_m(nk*nj*ni*nl)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_j*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_i*size_l);
    Index_type _k = linear / (size_j*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_l);
    Index_type _j = linear / (size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MKJLI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MKJLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*ni), stride_k(nj*nl*ni), stride_l(ni), stride_m(nk*nj*nl*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_j*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_l*size_i);
    Index_type _k = linear / (size_j*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_i);
    Index_type _j = linear / (size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MKLIJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MKLIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nl*ni*nj), stride_l(ni*nj), stride_m(nk*nl*ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_l*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_i*size_j);
    Index_type _k = linear / (size_l*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_j);
    Index_type _l = linear / (size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MKLJI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MKLJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nl*nj*ni), stride_l(nj*ni), stride_m(nk*nl*nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_l*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_j*size_i);
    Index_type _k = linear / (size_l*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_i);
    Index_type _l = linear / (size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MLIJK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MLIJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nj*nk), stride_m(nl*ni*nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_i*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_j*size_k);
    Index_type _l = linear / (size_i*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_k);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MLIKJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MLIKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nk*nj), stride_m(nl*ni*nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_i*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_k*size_j);
    Index_type _l = linear / (size_i*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_j);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MLJIK, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MLJIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nj*ni*nk), stride_m(nl*nj*ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_j*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_i*size_k);
    Index_type _l = linear / (size_j*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_k);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MLJKI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MLJKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nj*nk*ni), stride_m(nl*nj*nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_j*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_k*size_i);
    Index_type _l = linear / (size_j*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_i);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MLKIJ, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MLKIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nk*ni*nj), stride_m(nl*nk*ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_k*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_i*size_j);
    Index_type _l = linear / (size_k*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_j);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM, typename IdxLin>
struct Layout5d<PERM_MLKJI, IdxI, IdxJ, IdxK, IdxL, IdxM, IdxLin> {
  typedef PERM_MLKJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  inline Layout5d(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nk*nj*ni), stride_m(nl*nk*nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_k*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_j*size_i);
    Index_type _l = linear / (size_k*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_i);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};




} // namespace RAJA

#endif

