//AUTOGENERATED BY genLayout.py

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
// Copyright (c) 2016, Lawrence Livermore National Security, LLC.
// 
// Produced at the Lawrence Livermore National Laboratory
// 
// LLNL-CODE-689114
// 
// All rights reserved.
// 
// This file is part of RAJA. 
// 
// For additional details, please also read raja/README-license.txt.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are met:
// 
// * Redistributions of source code must retain the above copyright notice, 
//   this list of conditions and the disclaimer below.
// 
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the disclaimer (as noted below) in the
//   documentation and/or other materials provided with the distribution.
// 
// * Neither the name of the LLNS/LLNL nor the names of its contributors may
//   be used to endorse or promote products derived from this software without
//   specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL SECURITY,
// LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
// DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
// IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
// POSSIBILITY OF SUCH DAMAGE.
// 
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

  
#ifndef RAJA_LAYOUT_HXX__
#define RAJA_LAYOUT_HXX__

#include "RAJA/IndexValue.hxx"

namespace RAJA {

/******************************************************************
 *  Generic prototype for all Layouts
 ******************************************************************/

template<typename IdxLin, typename Perm, typename ... IdxList>
struct Layout {};



  
/******************************************************************
 *  Permutation tags
 ******************************************************************/
 

struct PERM_I {};
struct PERM_IJ {};
struct PERM_JI {};
struct PERM_IJK {};
struct PERM_IKJ {};
struct PERM_JIK {};
struct PERM_JKI {};
struct PERM_KIJ {};
struct PERM_KJI {};
struct PERM_IJKL {};
struct PERM_IJLK {};
struct PERM_IKJL {};
struct PERM_IKLJ {};
struct PERM_ILJK {};
struct PERM_ILKJ {};
struct PERM_JIKL {};
struct PERM_JILK {};
struct PERM_JKIL {};
struct PERM_JKLI {};
struct PERM_JLIK {};
struct PERM_JLKI {};
struct PERM_KIJL {};
struct PERM_KILJ {};
struct PERM_KJIL {};
struct PERM_KJLI {};
struct PERM_KLIJ {};
struct PERM_KLJI {};
struct PERM_LIJK {};
struct PERM_LIKJ {};
struct PERM_LJIK {};
struct PERM_LJKI {};
struct PERM_LKIJ {};
struct PERM_LKJI {};
struct PERM_IJKLM {};
struct PERM_IJKML {};
struct PERM_IJLKM {};
struct PERM_IJLMK {};
struct PERM_IJMKL {};
struct PERM_IJMLK {};
struct PERM_IKJLM {};
struct PERM_IKJML {};
struct PERM_IKLJM {};
struct PERM_IKLMJ {};
struct PERM_IKMJL {};
struct PERM_IKMLJ {};
struct PERM_ILJKM {};
struct PERM_ILJMK {};
struct PERM_ILKJM {};
struct PERM_ILKMJ {};
struct PERM_ILMJK {};
struct PERM_ILMKJ {};
struct PERM_IMJKL {};
struct PERM_IMJLK {};
struct PERM_IMKJL {};
struct PERM_IMKLJ {};
struct PERM_IMLJK {};
struct PERM_IMLKJ {};
struct PERM_JIKLM {};
struct PERM_JIKML {};
struct PERM_JILKM {};
struct PERM_JILMK {};
struct PERM_JIMKL {};
struct PERM_JIMLK {};
struct PERM_JKILM {};
struct PERM_JKIML {};
struct PERM_JKLIM {};
struct PERM_JKLMI {};
struct PERM_JKMIL {};
struct PERM_JKMLI {};
struct PERM_JLIKM {};
struct PERM_JLIMK {};
struct PERM_JLKIM {};
struct PERM_JLKMI {};
struct PERM_JLMIK {};
struct PERM_JLMKI {};
struct PERM_JMIKL {};
struct PERM_JMILK {};
struct PERM_JMKIL {};
struct PERM_JMKLI {};
struct PERM_JMLIK {};
struct PERM_JMLKI {};
struct PERM_KIJLM {};
struct PERM_KIJML {};
struct PERM_KILJM {};
struct PERM_KILMJ {};
struct PERM_KIMJL {};
struct PERM_KIMLJ {};
struct PERM_KJILM {};
struct PERM_KJIML {};
struct PERM_KJLIM {};
struct PERM_KJLMI {};
struct PERM_KJMIL {};
struct PERM_KJMLI {};
struct PERM_KLIJM {};
struct PERM_KLIMJ {};
struct PERM_KLJIM {};
struct PERM_KLJMI {};
struct PERM_KLMIJ {};
struct PERM_KLMJI {};
struct PERM_KMIJL {};
struct PERM_KMILJ {};
struct PERM_KMJIL {};
struct PERM_KMJLI {};
struct PERM_KMLIJ {};
struct PERM_KMLJI {};
struct PERM_LIJKM {};
struct PERM_LIJMK {};
struct PERM_LIKJM {};
struct PERM_LIKMJ {};
struct PERM_LIMJK {};
struct PERM_LIMKJ {};
struct PERM_LJIKM {};
struct PERM_LJIMK {};
struct PERM_LJKIM {};
struct PERM_LJKMI {};
struct PERM_LJMIK {};
struct PERM_LJMKI {};
struct PERM_LKIJM {};
struct PERM_LKIMJ {};
struct PERM_LKJIM {};
struct PERM_LKJMI {};
struct PERM_LKMIJ {};
struct PERM_LKMJI {};
struct PERM_LMIJK {};
struct PERM_LMIKJ {};
struct PERM_LMJIK {};
struct PERM_LMJKI {};
struct PERM_LMKIJ {};
struct PERM_LMKJI {};
struct PERM_MIJKL {};
struct PERM_MIJLK {};
struct PERM_MIKJL {};
struct PERM_MIKLJ {};
struct PERM_MILJK {};
struct PERM_MILKJ {};
struct PERM_MJIKL {};
struct PERM_MJILK {};
struct PERM_MJKIL {};
struct PERM_MJKLI {};
struct PERM_MJLIK {};
struct PERM_MJLKI {};
struct PERM_MKIJL {};
struct PERM_MKILJ {};
struct PERM_MKJIL {};
struct PERM_MKJLI {};
struct PERM_MKLIJ {};
struct PERM_MKLJI {};
struct PERM_MLIJK {};
struct PERM_MLIKJ {};
struct PERM_MLJIK {};
struct PERM_MLJKI {};
struct PERM_MLKIJ {};
struct PERM_MLKJI {};


/******************************************************************
 *  Implementation for Layout1D
 ******************************************************************/

template<typename IdxLin, typename IdxI>
struct Layout<IdxLin, PERM_I, IdxI> {
  typedef PERM_I Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;

  Index_type const size_i;

  Index_type const stride_i;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni):
    size_i(ni), stride_i(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i) const {
    Index_type linear = convertIndex<Index_type>(lin);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout2D
 ******************************************************************/

template<typename IdxLin, typename IdxI, typename IdxJ>
struct Layout<IdxLin, PERM_IJ, IdxI, IdxJ> {
  typedef PERM_IJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;

  Index_type const size_i;
  Index_type const size_j;

  Index_type const stride_i;
  Index_type const stride_j;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj):
    size_i(ni), size_j(nj), stride_i(nj), stride_j(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ>
struct Layout<IdxLin, PERM_JI, IdxI, IdxJ> {
  typedef PERM_JI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;

  Index_type const size_i;
  Index_type const size_j;

  Index_type const stride_i;
  Index_type const stride_j;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj):
    size_i(ni), size_j(nj), stride_i(1), stride_j(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout3D
 ******************************************************************/

template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
struct Layout<IdxLin, PERM_IJK, IdxI, IdxJ, IdxK> {
  typedef PERM_IJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nj*nk), stride_j(nk), stride_k(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
struct Layout<IdxLin, PERM_IKJ, IdxI, IdxJ, IdxK> {
  typedef PERM_IKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nk*nj), stride_j(1), stride_k(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
struct Layout<IdxLin, PERM_JIK, IdxI, IdxJ, IdxK> {
  typedef PERM_JIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nk), stride_j(ni*nk), stride_k(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
struct Layout<IdxLin, PERM_JKI, IdxI, IdxJ, IdxK> {
  typedef PERM_JKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(nk*ni), stride_k(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
struct Layout<IdxLin, PERM_KIJ, IdxI, IdxJ, IdxK> {
  typedef PERM_KIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nj), stride_j(1), stride_k(ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
struct Layout<IdxLin, PERM_KJI, IdxI, IdxJ, IdxK> {
  typedef PERM_KJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(ni), stride_k(nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout4D
 ******************************************************************/

template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_IJKL, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_IJKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_l);
    Index_type _j = linear / (size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_IJLK, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_IJLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_k);
    Index_type _j = linear / (size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_IKJL, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_IKJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_l);
    Index_type _k = linear / (size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_IKLJ, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_IKLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_j);
    Index_type _k = linear / (size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_ILJK, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_ILJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_k);
    Index_type _l = linear / (size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_ILKJ, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_ILKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_j);
    Index_type _l = linear / (size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_JIKL, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_JIKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl), stride_j(ni*nk*nl), stride_k(nl), stride_l(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_l);
    Index_type _i = linear / (size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_JILK, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_JILK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk), stride_j(ni*nl*nk), stride_k(1), stride_l(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_k);
    Index_type _i = linear / (size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_JKIL, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_JKIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(nk*ni*nl), stride_k(ni*nl), stride_l(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_l);
    Index_type _k = linear / (size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_JKLI, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_JKLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*nl*ni), stride_k(nl*ni), stride_l(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_i);
    Index_type _k = linear / (size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_JLIK, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_JLIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(nl*ni*nk), stride_k(1), stride_l(ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_k);
    Index_type _l = linear / (size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_JLKI, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_JLKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*nk*ni), stride_k(ni), stride_l(nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_i);
    Index_type _l = linear / (size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_KIJL, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_KIJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl), stride_j(nl), stride_k(ni*nj*nl), stride_l(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_l);
    Index_type _i = linear / (size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_KILJ, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_KILJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj), stride_j(1), stride_k(ni*nl*nj), stride_l(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_j);
    Index_type _i = linear / (size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_KJIL, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_KJIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(ni*nl), stride_k(nj*ni*nl), stride_l(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_l);
    Index_type _j = linear / (size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_KJLI, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_KJLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*ni), stride_k(nj*nl*ni), stride_l(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_i);
    Index_type _j = linear / (size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_KLIJ, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_KLIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(nl*ni*nj), stride_l(ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_j);
    Index_type _l = linear / (size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_KLJI, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_KLJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nl*nj*ni), stride_l(nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_i);
    Index_type _l = linear / (size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_LIJK, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_LIJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_k);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_LIKJ, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_LIKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_j);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_LJIK, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_LJIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nj*ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_k);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_LJKI, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_LJKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nj*nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_i);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_LKIJ, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_LKIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nk*ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_j);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
struct Layout<IdxLin, PERM_LKJI, IdxI, IdxJ, IdxK, IdxL> {
  typedef PERM_LKJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nk*nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_i);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout5D
 ******************************************************************/

template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IJKLM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IJKLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nl*nm), stride_j(nk*nl*nm), stride_k(nl*nm), stride_l(nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_l*size_m);
    Index_type _j = linear / (size_k*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_m);
    Index_type _k = linear / (size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IJKML, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IJKML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nm*nl), stride_j(nk*nm*nl), stride_k(nm*nl), stride_l(1), stride_m(nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_m*size_l);
    Index_type _j = linear / (size_k*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_l);
    Index_type _k = linear / (size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IJLKM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IJLKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nk*nm), stride_j(nl*nk*nm), stride_k(nm), stride_l(nk*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_l*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_k*size_m);
    Index_type _j = linear / (size_l*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_m);
    Index_type _l = linear / (size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IJLMK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IJLMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nm*nk), stride_j(nl*nm*nk), stride_k(1), stride_l(nm*nk), stride_m(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_l*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_m*size_k);
    Index_type _j = linear / (size_l*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_k);
    Index_type _l = linear / (size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IJMKL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IJMKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nk*nl), stride_j(nm*nk*nl), stride_k(nl), stride_l(1), stride_m(nk*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_m*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_k*size_l);
    Index_type _j = linear / (size_m*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_l);
    Index_type _m = linear / (size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IJMLK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IJMLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nl*nk), stride_j(nm*nl*nk), stride_k(1), stride_l(nk), stride_m(nl*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_m*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_l*size_k);
    Index_type _j = linear / (size_m*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_k);
    Index_type _m = linear / (size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IKJLM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IKJLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nl*nm), stride_j(nl*nm), stride_k(nj*nl*nm), stride_l(nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_l*size_m);
    Index_type _k = linear / (size_j*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_m);
    Index_type _j = linear / (size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IKJML, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IKJML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nm*nl), stride_j(nm*nl), stride_k(nj*nm*nl), stride_l(1), stride_m(nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_m*size_l);
    Index_type _k = linear / (size_j*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_l);
    Index_type _j = linear / (size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IKLJM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IKLJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nj*nm), stride_j(nm), stride_k(nl*nj*nm), stride_l(nj*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_l*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_j*size_m);
    Index_type _k = linear / (size_l*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_m);
    Index_type _l = linear / (size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IKLMJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IKLMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nm*nj), stride_j(1), stride_k(nl*nm*nj), stride_l(nm*nj), stride_m(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_l*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_m*size_j);
    Index_type _k = linear / (size_l*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_j);
    Index_type _l = linear / (size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IKMJL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IKMJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nj*nl), stride_j(nl), stride_k(nm*nj*nl), stride_l(1), stride_m(nj*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_m*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_j*size_l);
    Index_type _k = linear / (size_m*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_l);
    Index_type _m = linear / (size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IKMLJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IKMLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nl*nj), stride_j(1), stride_k(nm*nl*nj), stride_l(nj), stride_m(nl*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_m*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_l*size_j);
    Index_type _k = linear / (size_m*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_j);
    Index_type _m = linear / (size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_ILJKM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_ILJKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nk*nm), stride_j(nk*nm), stride_k(nm), stride_l(nj*nk*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_j*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_k*size_m);
    Index_type _l = linear / (size_j*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_m);
    Index_type _j = linear / (size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_ILJMK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_ILJMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nm*nk), stride_j(nm*nk), stride_k(1), stride_l(nj*nm*nk), stride_m(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_j*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_m*size_k);
    Index_type _l = linear / (size_j*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_k);
    Index_type _j = linear / (size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_ILKJM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_ILKJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nj*nm), stride_j(nm), stride_k(nj*nm), stride_l(nk*nj*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_k*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_j*size_m);
    Index_type _l = linear / (size_k*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_m);
    Index_type _k = linear / (size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_ILKMJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_ILKMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nm*nj), stride_j(1), stride_k(nm*nj), stride_l(nk*nm*nj), stride_m(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_k*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_m*size_j);
    Index_type _l = linear / (size_k*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_j);
    Index_type _k = linear / (size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_ILMJK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_ILMJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nj*nk), stride_j(nk), stride_k(1), stride_l(nm*nj*nk), stride_m(nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_m*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_j*size_k);
    Index_type _l = linear / (size_m*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_k);
    Index_type _m = linear / (size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_ILMKJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_ILMKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nk*nj), stride_j(1), stride_k(nj), stride_l(nm*nk*nj), stride_m(nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_m*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_k*size_j);
    Index_type _l = linear / (size_m*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_j);
    Index_type _m = linear / (size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IMJKL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IMJKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1), stride_m(nj*nk*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_j*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_k*size_l);
    Index_type _m = linear / (size_j*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_l);
    Index_type _j = linear / (size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IMJLK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IMJLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk), stride_m(nj*nl*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_j*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_l*size_k);
    Index_type _m = linear / (size_j*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_k);
    Index_type _j = linear / (size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IMKJL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IMKJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1), stride_m(nk*nj*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_k*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_j*size_l);
    Index_type _m = linear / (size_k*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_l);
    Index_type _k = linear / (size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IMKLJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IMKLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj), stride_m(nk*nl*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_k*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_l*size_j);
    Index_type _m = linear / (size_k*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_j);
    Index_type _k = linear / (size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IMLJK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IMLJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk), stride_m(nl*nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_l*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_j*size_k);
    Index_type _m = linear / (size_l*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_k);
    Index_type _l = linear / (size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_IMLKJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_IMLKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj), stride_m(nl*nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_m*size_l*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_k*size_j);
    Index_type _m = linear / (size_l*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_j);
    Index_type _l = linear / (size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JIKLM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JIKLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nm), stride_j(ni*nk*nl*nm), stride_k(nl*nm), stride_l(nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_l*size_m);
    Index_type _i = linear / (size_k*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_m);
    Index_type _k = linear / (size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JIKML, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JIKML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nl), stride_j(ni*nk*nm*nl), stride_k(nm*nl), stride_l(1), stride_m(nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_m*size_l);
    Index_type _i = linear / (size_k*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_l);
    Index_type _k = linear / (size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JILKM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JILKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nm), stride_j(ni*nl*nk*nm), stride_k(nm), stride_l(nk*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_l*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_k*size_m);
    Index_type _i = linear / (size_l*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_m);
    Index_type _l = linear / (size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JILMK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JILMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nk), stride_j(ni*nl*nm*nk), stride_k(1), stride_l(nm*nk), stride_m(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_l*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_m*size_k);
    Index_type _i = linear / (size_l*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_k);
    Index_type _l = linear / (size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JIMKL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JIMKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nl), stride_j(ni*nm*nk*nl), stride_k(nl), stride_l(1), stride_m(nk*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_m*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_k*size_l);
    Index_type _i = linear / (size_m*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_l);
    Index_type _m = linear / (size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JIMLK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JIMLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nk), stride_j(ni*nm*nl*nk), stride_k(1), stride_l(nk), stride_m(nl*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_m*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_l*size_k);
    Index_type _i = linear / (size_m*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_k);
    Index_type _m = linear / (size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JKILM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JKILM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm), stride_j(nk*ni*nl*nm), stride_k(ni*nl*nm), stride_l(nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_l*size_m);
    Index_type _k = linear / (size_i*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_m);
    Index_type _i = linear / (size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JKIML, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JKIML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl), stride_j(nk*ni*nm*nl), stride_k(ni*nm*nl), stride_l(1), stride_m(nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_m*size_l);
    Index_type _k = linear / (size_i*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_l);
    Index_type _i = linear / (size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JKLIM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JKLIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nk*nl*ni*nm), stride_k(nl*ni*nm), stride_l(ni*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_l*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_i*size_m);
    Index_type _k = linear / (size_l*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_m);
    Index_type _l = linear / (size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JKLMI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JKLMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nl*nm*ni), stride_k(nl*nm*ni), stride_l(nm*ni), stride_m(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_l*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_m*size_i);
    Index_type _k = linear / (size_l*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_i);
    Index_type _l = linear / (size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JKMIL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JKMIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nk*nm*ni*nl), stride_k(nm*ni*nl), stride_l(1), stride_m(ni*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_m*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_i*size_l);
    Index_type _k = linear / (size_m*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_l);
    Index_type _m = linear / (size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JKMLI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JKMLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nm*nl*ni), stride_k(nm*nl*ni), stride_l(ni), stride_m(nl*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_m*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_l*size_i);
    Index_type _k = linear / (size_m*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_i);
    Index_type _m = linear / (size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JLIKM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JLIKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm), stride_j(nl*ni*nk*nm), stride_k(nm), stride_l(ni*nk*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_i*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_k*size_m);
    Index_type _l = linear / (size_i*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_m);
    Index_type _i = linear / (size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JLIMK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JLIMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk), stride_j(nl*ni*nm*nk), stride_k(1), stride_l(ni*nm*nk), stride_m(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_i*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_m*size_k);
    Index_type _l = linear / (size_i*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_k);
    Index_type _i = linear / (size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JLKIM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JLKIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nl*nk*ni*nm), stride_k(ni*nm), stride_l(nk*ni*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_k*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_i*size_m);
    Index_type _l = linear / (size_k*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_m);
    Index_type _k = linear / (size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JLKMI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JLKMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nk*nm*ni), stride_k(nm*ni), stride_l(nk*nm*ni), stride_m(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_k*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_m*size_i);
    Index_type _l = linear / (size_k*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_i);
    Index_type _k = linear / (size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JLMIK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JLMIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nl*nm*ni*nk), stride_k(1), stride_l(nm*ni*nk), stride_m(ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_m*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_i*size_k);
    Index_type _l = linear / (size_m*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_k);
    Index_type _m = linear / (size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JLMKI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JLMKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nm*nk*ni), stride_k(ni), stride_l(nm*nk*ni), stride_m(nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_m*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_k*size_i);
    Index_type _l = linear / (size_m*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_i);
    Index_type _m = linear / (size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JMIKL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JMIKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl), stride_j(nm*ni*nk*nl), stride_k(nl), stride_l(1), stride_m(ni*nk*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_i*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_k*size_l);
    Index_type _m = linear / (size_i*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_l);
    Index_type _i = linear / (size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JMILK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JMILK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk), stride_j(nm*ni*nl*nk), stride_k(1), stride_l(nk), stride_m(ni*nl*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_i*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_l*size_k);
    Index_type _m = linear / (size_i*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_k);
    Index_type _i = linear / (size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JMKIL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JMKIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nm*nk*ni*nl), stride_k(ni*nl), stride_l(1), stride_m(nk*ni*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_k*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_i*size_l);
    Index_type _m = linear / (size_k*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_l);
    Index_type _k = linear / (size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JMKLI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JMKLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nk*nl*ni), stride_k(nl*ni), stride_l(ni), stride_m(nk*nl*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_k*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_l*size_i);
    Index_type _m = linear / (size_k*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_i);
    Index_type _k = linear / (size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JMLIK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JMLIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nm*nl*ni*nk), stride_k(1), stride_l(ni*nk), stride_m(nl*ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_l*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_i*size_k);
    Index_type _m = linear / (size_l*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_k);
    Index_type _l = linear / (size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_JMLKI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_JMLKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nl*nk*ni), stride_k(ni), stride_l(nk*ni), stride_m(nl*nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_m*size_l*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_k*size_i);
    Index_type _m = linear / (size_l*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_i);
    Index_type _l = linear / (size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KIJLM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KIJLM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nm), stride_j(nl*nm), stride_k(ni*nj*nl*nm), stride_l(nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_l*size_m);
    Index_type _i = linear / (size_j*size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_m);
    Index_type _j = linear / (size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KIJML, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KIJML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nl), stride_j(nm*nl), stride_k(ni*nj*nm*nl), stride_l(1), stride_m(nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_m*size_l);
    Index_type _i = linear / (size_j*size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_l);
    Index_type _j = linear / (size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KILJM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KILJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nm), stride_j(nm), stride_k(ni*nl*nj*nm), stride_l(nj*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_l*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_j*size_m);
    Index_type _i = linear / (size_l*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_m);
    Index_type _l = linear / (size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KILMJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KILMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm*nj), stride_j(1), stride_k(ni*nl*nm*nj), stride_l(nm*nj), stride_m(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_l*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_m*size_j);
    Index_type _i = linear / (size_l*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m*size_j);
    Index_type _l = linear / (size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KIMJL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KIMJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nl), stride_j(nl), stride_k(ni*nm*nj*nl), stride_l(1), stride_m(nj*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_m*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_j*size_l);
    Index_type _i = linear / (size_m*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_l);
    Index_type _m = linear / (size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KIMLJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KIMLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl*nj), stride_j(1), stride_k(ni*nm*nl*nj), stride_l(nj), stride_m(nl*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_m*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_l*size_j);
    Index_type _i = linear / (size_m*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l*size_j);
    Index_type _m = linear / (size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KJILM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KJILM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nm), stride_j(ni*nl*nm), stride_k(nj*ni*nl*nm), stride_l(nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i*size_l*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_l*size_m);
    Index_type _j = linear / (size_i*size_l*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_m);
    Index_type _i = linear / (size_l*size_m);
    i = IdxI(_i);
    linear -= _i*(size_l*size_m);
    Index_type _l = linear / (size_m);
    l = IdxL(_l);
    linear -= _l*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KJIML, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KJIML Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nl), stride_j(ni*nm*nl), stride_k(nj*ni*nm*nl), stride_l(1), stride_m(nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i*size_m*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_m*size_l);
    Index_type _j = linear / (size_i*size_m*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_l);
    Index_type _i = linear / (size_m*size_l);
    i = IdxI(_i);
    linear -= _i*(size_m*size_l);
    Index_type _m = linear / (size_l);
    m = IdxM(_m);
    linear -= _m*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KJLIM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KJLIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nl*ni*nm), stride_k(nj*nl*ni*nm), stride_l(ni*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_l*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_i*size_m);
    Index_type _j = linear / (size_l*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_m);
    Index_type _l = linear / (size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KJLMI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KJLMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nm*ni), stride_k(nj*nl*nm*ni), stride_l(nm*ni), stride_m(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_l*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_m*size_i);
    Index_type _j = linear / (size_l*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_m*size_i);
    Index_type _l = linear / (size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KJMIL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KJMIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nm*ni*nl), stride_k(nj*nm*ni*nl), stride_l(1), stride_m(ni*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_m*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_i*size_l);
    Index_type _j = linear / (size_m*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_l);
    Index_type _m = linear / (size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KJMLI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KJMLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nl*ni), stride_k(nj*nm*nl*ni), stride_l(ni), stride_m(nl*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_m*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_l*size_i);
    Index_type _j = linear / (size_m*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_l*size_i);
    Index_type _m = linear / (size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KLIJM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KLIJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm), stride_j(nm), stride_k(nl*ni*nj*nm), stride_l(ni*nj*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_i*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_j*size_m);
    Index_type _l = linear / (size_i*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_m);
    Index_type _i = linear / (size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KLIMJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KLIMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj), stride_j(1), stride_k(nl*ni*nm*nj), stride_l(ni*nm*nj), stride_m(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_i*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_m*size_j);
    Index_type _l = linear / (size_i*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_j);
    Index_type _i = linear / (size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KLJIM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KLJIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(ni*nm), stride_k(nl*nj*ni*nm), stride_l(nj*ni*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_j*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_i*size_m);
    Index_type _l = linear / (size_j*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_m);
    Index_type _j = linear / (size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KLJMI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KLJMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*ni), stride_k(nl*nj*nm*ni), stride_l(nj*nm*ni), stride_m(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_j*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_m*size_i);
    Index_type _l = linear / (size_j*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_i);
    Index_type _j = linear / (size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KLMIJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KLMIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nl*nm*ni*nj), stride_l(nm*ni*nj), stride_m(ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_m*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_i*size_j);
    Index_type _l = linear / (size_m*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_j);
    Index_type _m = linear / (size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KLMJI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KLMJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nl*nm*nj*ni), stride_l(nm*nj*ni), stride_m(nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_m*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_m*size_j*size_i);
    Index_type _l = linear / (size_m*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_i);
    Index_type _m = linear / (size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KMIJL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KMIJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl), stride_j(nl), stride_k(nm*ni*nj*nl), stride_l(1), stride_m(ni*nj*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_i*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_j*size_l);
    Index_type _m = linear / (size_i*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_l);
    Index_type _i = linear / (size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KMILJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KMILJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj), stride_j(1), stride_k(nm*ni*nl*nj), stride_l(nj), stride_m(ni*nl*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_i*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_l*size_j);
    Index_type _m = linear / (size_i*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_j);
    Index_type _i = linear / (size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KMJIL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KMJIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(ni*nl), stride_k(nm*nj*ni*nl), stride_l(1), stride_m(nj*ni*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_j*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_i*size_l);
    Index_type _m = linear / (size_j*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_l);
    Index_type _j = linear / (size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KMJLI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KMJLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*ni), stride_k(nm*nj*nl*ni), stride_l(ni), stride_m(nj*nl*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_j*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_l*size_i);
    Index_type _m = linear / (size_j*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_i);
    Index_type _j = linear / (size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KMLIJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KMLIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nm*nl*ni*nj), stride_l(ni*nj), stride_m(nl*ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_l*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_i*size_j);
    Index_type _m = linear / (size_l*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_j);
    Index_type _l = linear / (size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_KMLJI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_KMLJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nm*nl*nj*ni), stride_l(nj*ni), stride_m(nl*nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_m*size_l*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_l*size_j*size_i);
    Index_type _m = linear / (size_l*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_i);
    Index_type _l = linear / (size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LIJKM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LIJKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nm), stride_j(nk*nm), stride_k(nm), stride_l(ni*nj*nk*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_j*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_k*size_m);
    Index_type _i = linear / (size_j*size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_m);
    Index_type _j = linear / (size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LIJMK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LIJMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm*nk), stride_j(nm*nk), stride_k(1), stride_l(ni*nj*nm*nk), stride_m(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_j*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_m*size_k);
    Index_type _i = linear / (size_j*size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m*size_k);
    Index_type _j = linear / (size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LIKJM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LIKJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nm), stride_j(nm), stride_k(nj*nm), stride_l(ni*nk*nj*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_k*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_j*size_m);
    Index_type _i = linear / (size_k*size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_m);
    Index_type _k = linear / (size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LIKMJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LIKMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm*nj), stride_j(1), stride_k(nm*nj), stride_l(ni*nk*nm*nj), stride_m(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_k*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_m*size_j);
    Index_type _i = linear / (size_k*size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m*size_j);
    Index_type _k = linear / (size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LIMJK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LIMJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nm*nj*nk), stride_m(nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_m*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_j*size_k);
    Index_type _i = linear / (size_m*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j*size_k);
    Index_type _m = linear / (size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LIMKJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LIMKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nm*nk*nj), stride_m(nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_m*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_m*size_k*size_j);
    Index_type _i = linear / (size_m*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k*size_j);
    Index_type _m = linear / (size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LJIKM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LJIKM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nm), stride_j(ni*nk*nm), stride_k(nm), stride_l(nj*ni*nk*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_i*size_k*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_k*size_m);
    Index_type _j = linear / (size_i*size_k*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_m);
    Index_type _i = linear / (size_k*size_m);
    i = IdxI(_i);
    linear -= _i*(size_k*size_m);
    Index_type _k = linear / (size_m);
    k = IdxK(_k);
    linear -= _k*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LJIMK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LJIMK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nk), stride_j(ni*nm*nk), stride_k(1), stride_l(nj*ni*nm*nk), stride_m(nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_i*size_m*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_m*size_k);
    Index_type _j = linear / (size_i*size_m*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m*size_k);
    Index_type _i = linear / (size_m*size_k);
    i = IdxI(_i);
    linear -= _i*(size_m*size_k);
    Index_type _m = linear / (size_k);
    m = IdxM(_m);
    linear -= _m*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LJKIM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LJKIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(nk*ni*nm), stride_k(ni*nm), stride_l(nj*nk*ni*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_k*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_i*size_m);
    Index_type _j = linear / (size_k*size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_m);
    Index_type _k = linear / (size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LJKMI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LJKMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nm*ni), stride_k(nm*ni), stride_l(nj*nk*nm*ni), stride_m(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_k*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_m*size_i);
    Index_type _j = linear / (size_k*size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_m*size_i);
    Index_type _k = linear / (size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LJMIK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LJMIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nm*ni*nk), stride_k(1), stride_l(nj*nm*ni*nk), stride_m(ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_m*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_i*size_k);
    Index_type _j = linear / (size_m*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i*size_k);
    Index_type _m = linear / (size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LJMKI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LJMKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*nk*ni), stride_k(ni), stride_l(nj*nm*nk*ni), stride_m(nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_m*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_m*size_k*size_i);
    Index_type _j = linear / (size_m*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_k*size_i);
    Index_type _m = linear / (size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LKIJM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LKIJM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nm), stride_j(nm), stride_k(ni*nj*nm), stride_l(nk*ni*nj*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_i*size_j*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_j*size_m);
    Index_type _k = linear / (size_i*size_j*size_m);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_m);
    Index_type _i = linear / (size_j*size_m);
    i = IdxI(_i);
    linear -= _i*(size_j*size_m);
    Index_type _j = linear / (size_m);
    j = IdxJ(_j);
    linear -= _j*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LKIMJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LKIMJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm*nj), stride_j(1), stride_k(ni*nm*nj), stride_l(nk*ni*nm*nj), stride_m(nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_i*size_m*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_m*size_j);
    Index_type _k = linear / (size_i*size_m*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_m*size_j);
    Index_type _i = linear / (size_m*size_j);
    i = IdxI(_i);
    linear -= _i*(size_m*size_j);
    Index_type _m = linear / (size_j);
    m = IdxM(_m);
    linear -= _m*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LKJIM, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LKJIM Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nm), stride_j(ni*nm), stride_k(nj*ni*nm), stride_l(nk*nj*ni*nm), stride_m(1)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(m));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_j*size_i*size_m);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_i*size_m);
    Index_type _k = linear / (size_j*size_i*size_m);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_m);
    Index_type _j = linear / (size_i*size_m);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_m);
    Index_type _i = linear / (size_m);
    i = IdxI(_i);
    linear -= _i*(size_m);
    m = IdxM(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LKJMI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LKJMI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nm*ni), stride_k(nj*nm*ni), stride_l(nk*nj*nm*ni), stride_m(ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_j*size_m*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_m*size_i);
    Index_type _k = linear / (size_j*size_m*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_m*size_i);
    Index_type _j = linear / (size_m*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_m*size_i);
    Index_type _m = linear / (size_i);
    m = IdxM(_m);
    linear -= _m*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LKMIJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LKMIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nm*ni*nj), stride_l(nk*nm*ni*nj), stride_m(ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_m*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_i*size_j);
    Index_type _k = linear / (size_m*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_m*size_i*size_j);
    Index_type _m = linear / (size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LKMJI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LKMJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nm*nj*ni), stride_l(nk*nm*nj*ni), stride_m(nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_m*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_m*size_j*size_i);
    Index_type _k = linear / (size_m*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_m*size_j*size_i);
    Index_type _m = linear / (size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LMIJK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LMIJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(nm*ni*nj*nk), stride_m(ni*nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_i*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_j*size_k);
    Index_type _m = linear / (size_i*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_k);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LMIKJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LMIKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(nm*ni*nk*nj), stride_m(ni*nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_i*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_i*size_k*size_j);
    Index_type _m = linear / (size_i*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_j);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LMJIK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LMJIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nm*nj*ni*nk), stride_m(nj*ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_j*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_i*size_k);
    Index_type _m = linear / (size_j*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_k);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LMJKI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LMJKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nm*nj*nk*ni), stride_m(nj*nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_j*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_j*size_k*size_i);
    Index_type _m = linear / (size_j*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_i);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LMKIJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LMKIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nm*nk*ni*nj), stride_m(nk*ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_k*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_i*size_j);
    Index_type _m = linear / (size_k*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_j);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_LMKJI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_LMKJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nm*nk*nj*ni), stride_m(nk*nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_m*size_k*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_m*size_k*size_j*size_i);
    Index_type _m = linear / (size_k*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_i);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MIJKL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MIJKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1), stride_m(ni*nj*nk*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_j*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_k*size_l);
    Index_type _i = linear / (size_j*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_l);
    Index_type _j = linear / (size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MIJLK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MIJLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk), stride_m(ni*nj*nl*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_j*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_j*size_l*size_k);
    Index_type _i = linear / (size_j*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_k);
    Index_type _j = linear / (size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MIKJL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MIKJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1), stride_m(ni*nk*nj*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_k*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_j*size_l);
    Index_type _i = linear / (size_k*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_l);
    Index_type _k = linear / (size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MIKLJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MIKLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj), stride_m(ni*nk*nl*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_k*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_k*size_l*size_j);
    Index_type _i = linear / (size_k*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_j);
    Index_type _k = linear / (size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MILJK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MILJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk), stride_m(ni*nl*nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_l*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_j*size_k);
    Index_type _i = linear / (size_l*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_k);
    Index_type _l = linear / (size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MILKJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MILKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj), stride_m(ni*nl*nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_i*size_l*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_i*size_l*size_k*size_j);
    Index_type _i = linear / (size_l*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_j);
    Index_type _l = linear / (size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MJIKL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MJIKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nl), stride_j(ni*nk*nl), stride_k(nl), stride_l(1), stride_m(nj*ni*nk*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_i*size_k*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_k*size_l);
    Index_type _j = linear / (size_i*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_l);
    Index_type _i = linear / (size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MJILK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MJILK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nk), stride_j(ni*nl*nk), stride_k(1), stride_l(nk), stride_m(nj*ni*nl*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_i*size_l*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_i*size_l*size_k);
    Index_type _j = linear / (size_i*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_k);
    Index_type _i = linear / (size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MJKIL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MJKIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(nk*ni*nl), stride_k(ni*nl), stride_l(1), stride_m(nj*nk*ni*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_k*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_i*size_l);
    Index_type _j = linear / (size_k*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_l);
    Index_type _k = linear / (size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MJKLI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MJKLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*nl*ni), stride_k(nl*ni), stride_l(ni), stride_m(nj*nk*nl*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_k*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_k*size_l*size_i);
    Index_type _j = linear / (size_k*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_i);
    Index_type _k = linear / (size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MJLIK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MJLIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(nl*ni*nk), stride_k(1), stride_l(ni*nk), stride_m(nj*nl*ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_l*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_i*size_k);
    Index_type _j = linear / (size_l*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_k);
    Index_type _l = linear / (size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MJLKI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MJLKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*nk*ni), stride_k(ni), stride_l(nk*ni), stride_m(nj*nl*nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_j*size_l*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_j*size_l*size_k*size_i);
    Index_type _j = linear / (size_l*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_i);
    Index_type _l = linear / (size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MKIJL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MKIJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nl), stride_j(nl), stride_k(ni*nj*nl), stride_l(1), stride_m(nk*ni*nj*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_i*size_j*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_j*size_l);
    Index_type _k = linear / (size_i*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_l);
    Index_type _i = linear / (size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MKILJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MKILJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl*nj), stride_j(1), stride_k(ni*nl*nj), stride_l(nj), stride_m(nk*ni*nl*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_i*size_l*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_i*size_l*size_j);
    Index_type _k = linear / (size_i*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_j);
    Index_type _i = linear / (size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MKJIL, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MKJIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nl), stride_j(ni*nl), stride_k(nj*ni*nl), stride_l(1), stride_m(nk*nj*ni*nl)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_j*size_i*size_l);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_i*size_l);
    Index_type _k = linear / (size_j*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_l);
    Index_type _j = linear / (size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MKJLI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MKJLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nl*ni), stride_k(nj*nl*ni), stride_l(ni), stride_m(nk*nj*nl*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_j*size_l*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_j*size_l*size_i);
    Index_type _k = linear / (size_j*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_i);
    Index_type _j = linear / (size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MKLIJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MKLIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(nl*ni*nj), stride_l(ni*nj), stride_m(nk*nl*ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_l*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_i*size_j);
    Index_type _k = linear / (size_l*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_j);
    Index_type _l = linear / (size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MKLJI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MKLJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nl*nj*ni), stride_l(nj*ni), stride_m(nk*nl*nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_k*size_l*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_k*size_l*size_j*size_i);
    Index_type _k = linear / (size_l*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_i);
    Index_type _l = linear / (size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MLIJK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MLIJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nj*nk), stride_m(nl*ni*nj*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_i*size_j*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_j*size_k);
    Index_type _l = linear / (size_i*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_k);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MLIKJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MLIKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nk*nj), stride_m(nl*ni*nk*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_i*size_k*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_i*size_k*size_j);
    Index_type _l = linear / (size_i*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_j);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MLJIK, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MLJIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nj*ni*nk), stride_m(nl*nj*ni*nk)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_j*size_i*size_k);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_i*size_k);
    Index_type _l = linear / (size_j*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_k);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MLJKI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MLJKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nj*nk*ni), stride_m(nl*nj*nk*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_j*size_k*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_j*size_k*size_i);
    Index_type _l = linear / (size_j*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_i);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MLKIJ, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MLKIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nk*ni*nj), stride_m(nl*nk*ni*nj)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_k*size_i*size_j);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_i*size_j);
    Index_type _l = linear / (size_k*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_j);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxM>
struct Layout<IdxLin, PERM_MLKJI, IdxI, IdxJ, IdxK, IdxL, IdxM> {
  typedef PERM_MLKJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;
  typedef IdxM IndexM;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;
  Index_type const size_m;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;
  Index_type const stride_m;

  RAJA_INLINE RAJA_HOST_DEVICE constexpr Layout(Index_type ni, Index_type nj, Index_type nk, Index_type nl, Index_type nm):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), size_m(nm), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nk*nj*ni), stride_m(nl*nk*nj*ni)
  {}

  RAJA_INLINE RAJA_HOST_DEVICE constexpr IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l, IdxM m) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(m)*stride_m + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  RAJA_INLINE RAJA_HOST_DEVICE void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l, IdxM &m) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _m = linear / (size_l*size_k*size_j*size_i);
    m = IdxM(_m);
    linear -= _m*(size_l*size_k*size_j*size_i);
    Index_type _l = linear / (size_k*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_i);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};




} // namespace RAJA

#endif
  
